#! /bin/sh
#
# If these # comments don't work, trim them. Don't worry about any other
# shell scripts, Configure will trim # comments from them for you.
#
# (If you are trying to port this package to a machine without sh,
# I would suggest you have a look at the prototypical config_h.SH file
# and edit it to reflect your system. Some packages may include samples
# of config.h for certain machines, so you might look for one of those.)
#
# Yes, you may rip this off to use in other distribution packages. This
# script belongs to the public domain and cannot be copyrighted.
#
# Note: this Configure script was generated automatically. Rather than
# working with this copy of Configure, you may wish to get metaconfig.
# The dist package (which contains metaconfig) is available via SVN:
#     svn co https://svn.code.sf.net/p/dist/code/trunk/dist

# $Id: Head.U 167 2013-05-08 17:58:00Z rmanfredi $
#
# Generated on Sat Nov 14 16:05:58 CET 2015 [metaconfig 3.5-197]

cat >c1$$ <<EOF
ARGGGHHHH!!!!!

SCO csh still thinks true is false.  Write to SCO today and tell them that next
year Configure ought to "rm /bin/csh" unless they fix their blasted shell. :-)

(Actually, Configure ought to just patch csh in place.  Hmm.  Hmmmmm.  All
we'd have to do is go in and swap the && and || tokens, wherever they are.)

[End of diatribe. We now return you to your regularly scheduled programming...]
EOF
cat >c2$$ <<EOF

OOPS!  You naughty creature!  You didn't run Configure with sh!
I will attempt to remedy the situation by running sh for you...
EOF

true || cat c1$$ c2$$
true || exec sh $0 $argv:q

(exit $?0) || cat c2$$
(exit $?0) || exec sh $0 $argv:q
rm -f c1$$ c2$$

: compute my invocation name
me=$0
case "$0" in
*/*)
	me=`echo $0 | sed -e 's!.*/\(.*\)!\1!' 2>/dev/null`
	test "$me" || me=$0
	;;
esac

: Proper separator for the PATH environment variable
p_=:
: On OS/2 this directory should exist if this is not floppy only system ":-]"
if test -d c:/. ; then
	if test -n "$OS2_SHELL"; then
		p_=\;
		PATH=`cmd /c "echo %PATH%" | tr '\\\\' / `
		OS2_SHELL=`cmd /c "echo %OS2_SHELL%" | tr '\\\\' / | tr '[A-Z]' '[a-z]'`
	elif test -n "$DJGPP"; then
		case "X${MACHTYPE:-nonesuchmach}" in
		*cygwin|*msys) ;;
		*) p_=\; ;;
		esac
	fi
fi

: Proper PATH setting
paths='/bin /usr/bin /usr/local/bin /usr/ucb /usr/local /usr/lbin'
paths="$paths /opt/bin /opt/local/bin /opt/local /opt/lbin"
paths="$paths /usr/5bin /etc /usr/gnu/bin /usr/new /usr/new/bin /usr/nbin"
paths="$paths /opt/gnu/bin /opt/new /opt/new/bin /opt/nbin"
paths="$paths /sys5.3/bin /sys5.3/usr/bin /bsd4.3/bin /bsd4.3/usr/ucb"
paths="$paths /bsd4.3/usr/bin /usr/bsd /bsd43/bin /usr/ccs/bin"
paths="$paths /etc /usr/lib /usr/ucblib /lib /usr/ccs/lib"
paths="$paths /sbin /usr/sbin /usr/libexec"
paths="$paths /system/gnu_library/bin"

for p in $paths
do
	case "$p_$PATH$p_" in
	*$p_$p$p_*) ;;
	*) test -d $p && PATH=$PATH$p_$p ;;
	esac
done

PATH=.$p_$PATH
export PATH

: shall we be using ksh?
inksh=''
needksh=''
avoidksh=''
newsh=/bin/ksh
changesh=''
if (PATH=.; alias -x) >/dev/null 2>&1; then
		inksh=true
fi
if test -f /hp-ux -a -f /bin/ksh; then
	needksh='to avoid sh bug in "here document" expansion'
fi
if test -d /usr/lpp -a -f /usr/bin/bsh -a -f /usr/bin/uname; then
	if test X`/usr/bin/uname -v` = X4; then
		avoidksh="to avoid AIX 4's /bin/sh"
		newsh=/usr/bin/bsh
	fi
fi
if test -f /osf_boot -a -f /usr/sbin/setld; then
	if test X`/usr/bin/uname -s` = XOSF1; then
		avoidksh="to avoid Digital UNIX' ksh"
		newsh=/bin/sh
		unset BIN_SH
	fi
fi
case "$inksh/$needksh" in
/[a-z]*)
		ENV=''
		changesh=true
		reason="$needksh"
	;;
esac
case "$inksh/$avoidksh" in
true/[a-z]*)
	changesh=true
	reason="$avoidksh"
	;;
esac
case "$inksh/$needksh-$avoidksh-" in
true/--)
		cat <<EOM
(I see you are using the Korn shell.  Some ksh's blow up on $me,
mainly on older exotic systems.  If yours does, try the Bourne shell instead.)
EOM
	;;
esac
case "$changesh" in
true)
	export newsh
	echo "(Feeding myself to $newsh $reason.)"
	case "$0" in
	Configure|*/Configure) exec $newsh $0 "$@";;
	*) exec $newsh Configure "$@";;
	esac
	;;
esac

: if needed, set CDPATH to a harmless value that is not chatty
case "$CDPATH" in
'')	;;
*)	case "$SHELL" in
	*bash*) CDPATH='.' ;;
	*) CDPATH='' ;;
	esac
	;;
esac

: Configure runs within the UU subdirectory
test -d UU || mkdir UU
cd UU && rm -f ./*

ccname=''
ccversion=''
from=''
run=''
targetarch=''
to=''
usecrosscompile=''
d_bsd=''
d_dos=''
d_eunice=''
d_linux=''
d_os2=''
d_windows=''
d_xenix=''
_exe=''
eunicefix=''
ar=''
awk=''
bash=''
bison=''
byacc=''
cat=''
chgrp=''
chmod=''
chown=''
comm=''
compress=''
cp=''
cpio=''
cpp=''
csh=''
date=''
echo=''
egrep=''
emacs=''
expr=''
find=''
flex=''
gcc=''
gmake=''
gmsgfmt=''
grep=''
gzip=''
inews=''
ksh=''
less=''
line=''
lint=''
ln=''
lp=''
lpr=''
ls=''
mail=''
mailx=''
make=''
mkdir=''
more=''
msgfmt=''
msgmerge=''
mv=''
nawk=''
nm=''
nroff=''
perl=''
pg=''
pmake=''
pr=''
rm=''
rmail=''
sed=''
sendmail=''
shar=''
sleep=''
smail=''
sort=''
submit=''
tail=''
tar=''
tbl=''
tee=''
test=''
touch=''
tr=''
troff=''
uname=''
uniq=''
uuname=''
vi=''
wc=''
xgettext=''
zcat=''
zip=''
incpath=''
mips_type=''
hint=''
myuname=''
osname=''
osvers=''
Author=''
Date=''
Header=''
Id=''
Locker=''
Log=''
RCSfile=''
Revision=''
Source=''
State=''
_a=''
_o=''
archobjs=''
firstmakefile=''
afs=''
afsroot=''
baserev=''
ccflags=''
cppflags=''
ldflags=''
lkflags=''
locincpth=''
optimize=''
pthread=''
cf_email=''
cf_by=''
cf_time=''
contains=''
cpp_trad=''
cpplast=''
cppminus=''
cpprun=''
cppstdin=''
d_portable=''
defeditor=''
gccosandvers=''
gccversion=''
install=''
installdir=''
issymlink=''
glibpth=''
libpth=''
loclibpth=''
plibpth=''
xlibpth=''
lns=''
mailer=''
make_set_make=''
installmansrc=''
manext=''
mansrc=''
mansrcexp=''
mydomain=''
myhostname=''
phostname=''
c=''
n=''
d_berknames=''
d_passnames=''
d_usgnames=''
nametype=''
groupcat=''
hostcat=''
passcat=''
orgname=''
package=''
spackage=''
pager=''
patchlevel=''
revision=''
perlpath=''
pkgsrc=''
prefix=''
prefixexp=''
installprivlib=''
privlib=''
privlibexp=''
installscript=''
scriptdir=''
scriptdirexp=''
sh=''
sharpbang=''
shsharp=''
spitshell=''
src=''
startperl=''
startsh=''
sysman=''
trnl=''
usrinc=''
CONFIG=''

: Initialize wide constants
define='define'
undef='undef'
smallmach='pdp11 i8086 z8000 i80286 iAPX286'
rmlist=''

: We must find out about Eunice early
eunicefix=':'
if test -f /etc/unixtovms; then
	eunicefix=/etc/unixtovms
fi
if test -f /etc/unixtovms.exe; then
	eunicefix=/etc/unixtovms.exe
fi

: Set executable suffix now -- needed before hints available
if test -f "/libs/version.library"; then
	: Amiga OS
	 _exe=""
elif test -f "/system/gnu_library/bin/ar.pm"; then
	: Stratus VOS
	_exe=".pm"
elif test -n "$DJGPP"; then
	: DOS DJGPP
	 _exe=".exe"
elif test -d c:/. ; then
	: OS/2 or cygwin
	_exe=".exe"
else
	: All other UNIX systems
	_exe=""
fi

ccname=''
ccversion=''
: Extra object files, if any, needed on this platform.
archobjs=''
bin='/usr/local/bin'
cc='cc'
: Possible local include directories to search.
: Set locincpth to "" in a hint file to defeat local include searches.
locincpth=""
:
: no include file wanted by default
inclwanted=''

: change the next line if compiling for Xenix/286 on Xenix/386
xlibpth='/usr/lib/386 /lib/386'
: Possible local library directories to search.
loclibpth=""

: general looking path for locating libraries
glibpth="/lib /usr/lib $xlibpth"
glibpth="$glibpth /usr/ccs/lib /usr/ucblib /usr/local/lib"
test -f /usr/shlib/libc.so && glibpth="/usr/shlib $glibpth"
test -f /shlib/libc.so     && glibpth="/shlib $glibpth"
glibpth="$glibpth /lib32 /lib64 "`ls -1d /usr/lib/*-gnu 2>/dev/null`
: Private path used by Configure to find libraries.  Its value
: is prepended to libpth. This variable takes care of special
: machines, like the mips.  Usually, it should be empty.
plibpth=''

: Find the basic shell for Bourne shell scripts
case "$sh" in
'')
	case "$SYSTYPE" in
	*bsd*|sys5*) xxx="/$SYSTYPE/bin/sh";;
	*) xxx='/bin/sh';;
	esac
	if test -f "$xxx"; then
		sh="$xxx"
	else
		: Build up a list and do a single loop so we can 'break' out.
		pth=`echo $PATH | sed -e "s/$p_/ /g"`
		for xxx in sh bash ksh pdksh ash; do
			for p in $pth; do
				try="$try ${p}/${xxx}"
			done
		done
		for xxx in $try; do
			if test -f "$xxx"; then
				sh="$xxx"
				break
			elif test -f "$xxx$_exe"; then
				sh="$xxx$_exe"
				break
			elif test -f "$xxx.exe"; then
				sh="$xxx.exe"
				break
			fi
		done
	fi
	;;
esac

case "$sh" in
'')	cat >&2 <<EOM
$me:  Fatal Error:  I can't find a Bourne Shell anywhere.  

Usually it's in /bin/sh.  How did you even get this far?
Please contact me (Raphael Manfredi) at Raphael_Manfredi@pobox.com and 
we'll try to straighten this all out.
EOM
	exit 1
	;;
esac

: see if sh knows # comments
if `$sh -c '#' >/dev/null 2>&1`; then
	shsharp=true
	spitshell=cat
	xcat=/bin/cat
	test -f $xcat$_exe || xcat=/usr/bin/cat
	if test ! -f $xcat$_exe; then
		for p in `echo $PATH | sed -e "s/$p_/ /g"` $paths; do
			if test -f $p/cat$_exe; then
				xcat=$p/cat
				break
			fi
		done
		if test ! -f $xcat$_exe; then
			echo "Can't find cat anywhere!"
			exit 1
		fi
	fi
	echo "#!$xcat" >sharp
	$eunicefix sharp
	chmod +x sharp
	./sharp > today 2>/dev/null
	if test -s today; then
		sharpbang='#!'
	else
		echo "#! $xcat" > sharp
		$eunicefix sharp
		chmod +x sharp
		./sharp > today 2>/dev/null
		if test -s today; then
			sharpbang='#! '
		else
			sharpbang=': use '
		fi
	fi
else
	echo " "
	echo "Your $sh doesn't grok # comments--I will strip them later on."
	shsharp=false
	cd ..
	echo "exec grep -v '^[ 	]*#'" >spitshell
	chmod +x spitshell
	$eunicefix spitshell
	spitshell=`pwd`/spitshell
	cd UU
	echo "I presume that if # doesn't work, #! won't work either!"
	sharpbang=': use '
fi
rm -f sharp today

: figure out how to guarantee sh startup
case "$startsh" in
'') startsh=${sharpbang}${sh} ;;
*)
esac
cat >sharp <<EOSS
$startsh
set abc
test "$?abc" != 1
EOSS

chmod +x sharp
$eunicefix sharp
if ./sharp; then
	: echo "Yup, it does."
else
	echo "Hmm... '$startsh' does not guarantee sh startup..."
	echo "You may have to fix up the shell scripts to make sure $sh runs them."
fi
rm -f sharp

: Save command line options in file UU/cmdline.opt for later use in
: generating config.sh.
cat > cmdline.opt <<EOSH
: Configure command line arguments.
config_arg0='$0'
config_args='$*'
config_argc=$#
EOSH
argn=1
args_exp=''
args_sep=''
for arg in "$@"; do
	cat >>cmdline.opt <<EOSH
config_arg$argn='$arg'
EOSH
	cat <<EOC | sed -e "s/'/'"'"'"'"'"'"'/g" > cmdl.opt
$arg
EOC
	arg_exp=`cat cmdl.opt`
	args_exp="$args_exp$args_sep'$arg_exp'"
	argn=`expr $argn + 1`
	args_sep=' '
done
rm -f cmdl.opt

: produce awk script to parse command line options
cat >options.awk <<'EOF'
BEGIN {
	optstr = "A:dD:eEf:hKOrsSU:V";	# getopt-style specification

	len = length(optstr);
	for (i = 1; i <= len; i++) {
		c = substr(optstr, i, 1);
		if (i < len) a = substr(optstr, i + 1, 1); else a = "";
		if (a == ":") {
			arg[c] = 1;
			i++;
		}
		opt[c] = 1;
	}
}
{
	expect = 0;
	str = $0;
	if (substr(str, 1, 1) != "-") {
		printf("'%s'\n", str);
		next;
	}
	len = length($0);
	for (i = 2; i <= len; i++) {
		c = substr(str, i, 1);
		if (!opt[c]) {
			printf("-%s\n", substr(str, i));
			next;
		}
		printf("-%s\n", c);
		if (arg[c]) {
			if (i < len)
				printf("'%s'\n", substr(str, i + 1));
			else
				expect = 1;
			next;
		}
	}
}
END {
	if (expect)
		print "?";
}
EOF

: process the command line options
set X `for arg in "$@"; do echo "X$arg"; done |
	sed -e s/X// | awk -f options.awk`
eval "set $*"
shift
rm -f options.awk

: set up default values
fastread=''
reuseval=false
config_sh=''
alldone=''
error=''
silent=''
extractsh=''
override=''
knowitall=''
rm -f optdef.sh posthint.sh
cat >optdef.sh <<EOS
$startsh
EOS


: option parsing
while test $# -gt 0; do
	case "$1" in
	-d) shift; fastread=yes;;
	-e) shift; alldone=cont;;
	-f)
		shift
		cd ..
		if test -r "$1"; then
			config_sh="$1"
		else
			echo "$me: cannot read config file $1." >&2
			error=true
		fi
		cd UU
		shift;;
	-h) shift; error=true;;
	-r) shift; reuseval=true;;
	-s) shift; silent=true; realsilent=true;;
	-E) shift; alldone=exit;;
	-K) shift; knowitall=true;;
	-O) shift; override=true;;
	-S) shift; silent=true; extractsh=true;;
	-D)
		shift
		case "$1" in
		*=)
			echo "$me: use '-U symbol=', not '-D symbol='." >&2
			echo "$me: ignoring -D $1" >&2
			;;
		*=*) echo "$1" | \
				sed -e "s/'/'\"'\"'/g" -e "s/=\(.*\)/='\1'/" >> optdef.sh;;
		*) echo "$1='define'" >> optdef.sh;;
		esac
		shift
		;;
	-U)
		shift
		case "$1" in
		*=) echo "$1" >> optdef.sh;;
		*=*)
			echo "$me: use '-D symbol=val', not '-U symbol=val'." >&2
			echo "$me: ignoring -U $1" >&2
			;;
		*) echo "$1='undef'" >> optdef.sh;;
		esac
		shift
		;;
	-A)
	    shift
	    xxx=''
	    yyy="$1"
	    zzz=''
	    uuu=undef
	    case "$yyy" in
            *=*) zzz=`echo "$yyy"|sed 's!=.*!!'`
                 case "$zzz" in
                 *:*) zzz='' ;;
                 *)   xxx=append
                      zzz=" "`echo "$yyy"|sed 's!^[^=]*=!!'` 
                      yyy=`echo "$yyy"|sed 's!=.*!!'` ;;
                 esac
                 ;;
            esac
            case "$xxx" in
            '')  case "$yyy" in
                 *:*) xxx=`echo "$yyy"|sed 's!:.*!!'`
                      yyy=`echo "$yyy"|sed 's!^[^:]*:!!'`
                      zzz=`echo "$yyy"|sed 's!^[^=]*=!!'`
                      yyy=`echo "$yyy"|sed 's!=.*!!'` ;;
                 *)   xxx=`echo "$yyy"|sed 's!:.*!!'`
                      yyy=`echo "$yyy"|sed 's!^[^:]*:!!'` ;;
                 esac
                 ;;       
            esac
	    case "$xxx" in
	    append)
		echo "$yyy=\"\${$yyy}$zzz\""	>> posthint.sh ;;
	    clear)
		echo "$yyy=''"			>> posthint.sh ;;
	    define)
	        case "$zzz" in
		'') zzz=define ;;
		esac
		echo "$yyy='$zzz'"		>> posthint.sh ;;
	    eval)
		echo "eval \"$yyy=$zzz\""	>> posthint.sh ;;
	    prepend)
		echo "$yyy=\"$zzz\${$yyy}\""	>> posthint.sh ;;
	    undef)
	        case "$zzz" in
		'') zzz="$uuu" ;;
		esac
		echo "$yyy=$zzz"		>> posthint.sh ;;
            *)  echo "$me: unknown -A command '$xxx', ignoring -A $1" >&2 ;;
	    esac
	    shift
	    ;;
	-V) echo "$me generated by metaconfig 3.5-197." >&2
	    exit 0;;
	--) break;;
	-*) echo "$me: unknown option $1" >&2; shift; error=true;;
	*) break;;
	esac
done

case "$error" in
true)
	cat >&2 <<EOM
Usage: $me [-dehrsEKOSV] [-f config.sh] [-D symbol] [-D symbol=value]
                 [-U symbol] [-U symbol=] [-A command:symbol...]
  -d : use defaults for all answers.
  -e : go on without questioning past the production of config.sh.
  -f : specify an alternate default configuration file.
  -h : print this help message and exit (with an error status).
  -r : reuse C symbols value if possible (skips costly nm extraction).
  -s : silent mode, only echoes questions and essential information.
  -D : define symbol to have some value:
         -D symbol         symbol gets the value 'define'
         -D symbol=value   symbol gets the value 'value'
  -E : stop at the end of questions, after having produced config.sh.
  -K : do not use unless you know what you are doing.
  -O : let -D and -U override definitions from loaded configuration file.
  -S : perform variable substitutions on all .SH files (can mix with -f)
  -U : undefine symbol:
         -U symbol    symbol gets the value 'undef'
         -U symbol=   symbol gets completely empty
  -A : manipulate symbol after the platform specific hints have been applied:
	 -A symbol=value		append " "value to symbol
	 -A append:symbol=value		append value to symbol
	 -A define:symbol=value		define symbol to have value
         -A clear:symbol		define symbol to be ''
	 -A define:symbol		define symbol to be 'define'
	 -A eval:symbol=value		define symbol to be eval of value
	 -A prepend:symbol=value	prepend value to symbol
	 -A undef:symbol		define symbol to be 'undef'
	 -A undef:symbol=		define symbol to be ''
  -V : print version number and exit (with a zero status).
EOM
	exit 1
	;;
esac

: Sanity checks
case "$fastread$alldone" in
yescont|yesexit) ;;
*)
	case "$extractsh" in
	true) ;;
	*)
		if test ! -t 0; then
			echo "Say 'sh Configure', not 'sh <Configure'"
			exit 1
		fi
		;;
	esac
	;;
esac

exec 4>&1
case "$silent" in
true) exec 1>/dev/null;;
esac

touch optdef.sh
if grep -q '\\' optdef.sh >/dev/null 2>&1; then
	echo "Configure does not support \\ in -D or -U arguments" >&2
	exit 1
fi

: run the defines and the undefines, if any, but leave the file out there...
. ./optdef.sh
: create the posthint manipulation script and leave the file out there...
touch posthint.sh

: set package name
package='dist'
first=`echo $package | sed -e 's/^\(.\).*/\1/'`
last=`echo $package | sed -e 's/^.\(.*\)/\1/'`
case "`echo AbyZ | tr '[:lower:]' '[:upper:]' 2>/dev/null`" in
ABYZ) spackage=`echo $first | tr '[:lower:]' '[:upper:]'`$last;;
*) spackage=`echo $first | tr '[a-z]' '[A-Z]'`$last;;
esac

: script used to emulate mkdir -p
cat >mkdirp <<EOS
$startsh
EOS
cat >>mkdirp <<'EOS'
name=$1;
create="";
while test $name; do
	if test ! -d "$name"; then
		create="$name $create"
		name=`echo $name | sed -e "s|^[^/]*$||"`
		name=`echo $name | sed -e "s|\(.*\)/.*|\1|"`
	else
		name=""
	fi
done
for file in $create; do
	mkdir $file
done
EOS
chmod +x mkdirp
$eunicefix mkdirp

: Some greps do not return status, grrr.
echo "grimblepritz" >grimble
if grep blurfldyick grimble >/dev/null 2>&1 ; then
	contains=contains
elif grep grimblepritz grimble >/dev/null 2>&1 ; then
	contains=grep
else
	contains=contains
fi
rm -f grimble
: the following should work in any shell
case "$contains" in
contains*)
	echo " "
	echo "AGH!  Grep doesn't return a status.  Attempting remedial action."
	cat >contains <<'EOSS'
grep "$1" "$2" >.greptmp && cat .greptmp && test -s .greptmp
EOSS
chmod +x contains
esac

: Find the path to the source tree
case "$src" in
'') case "$0" in
    */*)
		src=`echo $0 | sed -e 's%/[^/][^/]*$%%'`
		;;
    *)	src='.';;
    esac;;
esac
case "$src" in
'')	src=/
	rsrc=/
	;;
/*)	rsrc="$src";;
*)	rsrc="../$src";;
esac
if test -f $rsrc/Configure && \
	$contains "^package='$package'\$" $rsrc/Configure >/dev/null 2>&1
then
   : found it, so we are ok.
else
	rsrc=''
	for src in . .. ../.. ../../.. ../../../..; do
		if test -f ../$src/Configure && \
			$contains "^package=$package$" ../$src/Configure >/dev/null 2>&1
		then
			rsrc=../$src
			break
		fi
	done
fi
case "$rsrc" in
'')
	cat <<EOM >&4

Sorry, I can't seem to locate the source dir for $package.  Please start
Configure with an explicit path -- i.e. /some/path/Configure.

EOM
	exit 1
	;;
../.)	rsrc='..';;
*)
	echo " "
	echo "Sources for $package found in \"$src\"." >&4
	;;
esac

: script used to extract .SH files with variable substitutions
cat >extract <<EOS
CONFIG=true
SRC="$src"
TOP=`cd ..; pwd 2>/dev/null`
EOS
cat >>extract <<'EOS'
echo "Doing variable substitutions on .SH files..."
if test -f "$SRC/MANIFEST"; then
	set x `awk '{print $1}' <$SRC/MANIFEST | grep '\.SH'`
else
	echo "(Looking for .SH files under the source directory.)"
	set x `(cd "$SRC"; find . -name "*.SH" -print)`
fi
shift
case $# in
0) set x `(cd "$SRC"; echo *.SH)`; shift;;
esac
if test ! -f "$SRC/$1"; then
	shift
fi
for file in $*; do
	case "$SRC" in
	".")
		case "$file" in
		*/*)
			dir=`expr X$file : 'X\(.*\)/'`
			file=`expr X$file : 'X.*/\(.*\)'`
			(cd $dir && . ./$file)
			;;
		*)
			. ./$file
			;;
		esac
		;;
	*)
		case "$file" in
		*/*)
			dir=`expr X$file : 'X\(.*\)/'`
			file=`expr X$file : 'X.*/\(.*\)'`
			./mkdirp $dir
			sh <"$SRC/$dir/$file"
			;;
		*)
			sh <"$SRC/$file"
			;;
		esac
		;;
	esac
done
if test -f "$SRC/config_h.SH"; then
	if test ! -f config.h; then
		sh <"$SRC/config_h.SH"
	fi
fi
EOS

: extract files and exit if asked to do so
case "$extractsh" in
true)
	case "$realsilent" in
	true) ;;
	*) exec 1>&4;;
	esac
	case "$config_sh" in
	'') config_sh='config.sh';;
	esac
	echo " "
	echo "Fetching answers from $config_sh..."
	cd ..
	. $config_sh
	test "$override" && . ./optdef.sh
	echo " "
	. UU/extract
	rm -rf UU
	echo "Extraction done."
	exit 0
	;;
esac

: Eunice requires " " instead of "", can you believe it
echo " "
: Here we go...
echo "Beginning of configuration questions for $package."

trap 'echo " "; test -d ../UU && rm -rf X $rmlist; exit 1' 1 2 3 15

: first determine how to suppress newline on echo command
echo " "
echo "Checking echo to see how to suppress newlines..."
(echo "hi there\c" ; echo " ") >.echotmp
if $contains c .echotmp >/dev/null 2>&1 ; then
	echo "...using -n."
	n='-n'
	c=''
else
	cat <<'EOM'
...using \c
EOM
	n=''
	c='\c'
fi
echo $n "The star should be here-->$c"
echo '*'
rm -f .echotmp

: Now test for existence of everything in MANIFEST
echo " "
if test -f "$rsrc/MANIFEST"; then
	echo "First let's make sure your kit is complete.  Checking..." >&4
	awk '$1 !~ /PACK[A-Z]+/ {print $1}' "$rsrc/MANIFEST" | \
		(split -l 50 2>/dev/null || split -50)
	rm -f missing
	tmppwd=`pwd`
	for filelist in x??; do
		(cd "$rsrc"; ls `cat "$tmppwd/$filelist"` \
			>/dev/null 2>>"$tmppwd/missing")
	done
	if test -s missing; then
		cat missing >&4
		cat >&4 <<'EOM'

THIS PACKAGE SEEMS TO BE INCOMPLETE.

You have the option of continuing the configuration process, despite the
distinct possibility that your kit is damaged, by typing 'y'es.  If you
do, don't blame me if something goes wrong.  I advise you to type 'n'o
and contact the author (Raphael_Manfredi@pobox.com).

EOM
		echo $n "Continue? [n] $c" >&4
		read ans
		case "$ans" in
		y*)
			echo "Continuing..." >&4
			rm -f missing
			;;
		*)
			echo "ABORTING..." >&4
			kill $$
			;;
		esac
	else
		echo "Looks good..."
	fi
else
	echo "There is no MANIFEST file.  I hope your kit is complete !"
fi
rm -f missing x??

: Find the appropriate value for a newline for tr
if test -n "$DJGPP"; then
       trnl='\012'
fi
if test X"$trnl" = X; then
	case "`echo foo | tr '\n' x 2>/dev/null`" in
	foox) trnl='\n' ;;
	esac
fi
if test X"$trnl" = X; then
	case "`echo foo | tr '\012' x 2>/dev/null`" in
	foox) trnl='\012' ;;
	esac
fi
if test X"$trnl" = X; then
       case "`echo foo | tr '\r\n' xy 2>/dev/null`" in
       fooxy) trnl='\n\r' ;;
       esac
fi
if test X"$trnl" = X; then
	cat <<EOM >&2

$me: Fatal Error: cannot figure out how to translate newlines with 'tr'.

EOM
	exit 1
fi

: compute the number of columns on the terminal for proper question formatting
case "$COLUMNS" in
'') COLUMNS='80';;
esac

: set up the echo used in my read
myecho="case \"\$xxxm\" in
'') echo $n \"\$rp $c\" >&4;;
*) case \"\$rp\" in
	'') echo $n \"[\$xxxm] $c\";;
	*)
		if test \`echo \"\$rp [\$xxxm]  \" | wc -c\` -ge $COLUMNS; then
			echo \"\$rp\" >&4
			echo $n \"[\$xxxm] $c\" >&4
		else
			echo $n \"\$rp [\$xxxm] $c\" >&4
		fi
		;;
	esac;;
esac"

: now set up to do reads with possible shell escape and default assignment
cat <<EOSC >myread
$startsh
xxxm=\$dflt
$myecho
ans='!'
case "\$fastread" in
yes) case "\$dflt" in
	'') ;;
	*) ans='';
		case "\$silent-\$rp" in
		true-) ;;
		*) echo " " >&4;;
		esac;;
	esac;;
*) case "\$silent" in
	true) case "\$rp" in
		'') ans='';;
		esac;;
	esac;;
esac
while expr "X\$ans" : "X!" >/dev/null; do
	read answ
	set x \$xxxm
	shift
	aok=''; eval "ans=\\"\$answ\\"" && aok=y
	case  "\$answ" in
	"!")
		sh 1>&4
		echo " "
		$myecho
		;;
	!*)
		set x \`expr "X\$ans" : "X!\(.*\)\$"\`
		shift
		sh 1>&4 -c "\$*"
		echo " "
		$myecho
		;;
	"\$ans")
		case "\$ans" in
		\\&*)
			set x \`expr "X\$ans" : "X&\(.*\)\$"\`
			shift
			case "\$1" in
			-d)
				fastread=yes
				echo "(OK, I'll run with -d after this question.)" >&4
				;;
			-*)
				echo "*** Sorry, \$1 not supported yet." >&4
				;;
			esac
			$myecho
			ans=!
			;;
		esac;;
	*)
		case "\$aok" in
		y)
			echo "*** Substitution done -- please confirm."
			xxxm="\$ans"
			ans=\`echo $n "\$ans$c" | tr '$trnl' ' '\`
			xxxm="\$ans"
			ans=!
			;;
		*)
			echo "*** Error -- try again."
			ans=!
			;;
		esac
		$myecho
		;;
	esac
	case "\$ans\$xxxm\$nostick" in
	'')
		ans=!
		$myecho
		;;
	esac
done
case "\$ans" in
'') ans="\$xxxm";;
esac
EOSC

: create .config dir to save info across Configure sessions
test -d ../.config || mkdir ../.config
cat >../.config/README <<EOF
This directory created by Configure to save information that should
persist across sessions for $package.

You may safely delete it if you wish.
EOF

: general instructions
needman=true
firsttime=true
user=`(logname) 2>/dev/null`
case "$user" in
'') user=`whoami 2>&1`;;
esac
if $contains "^$user\$" ../.config/instruct >/dev/null 2>&1; then
	firsttime=false
	echo " "
	rp='Would you like to see the instructions?'
	dflt=n
	. ./myread
	case "$ans" in
	[yY]*) ;;
	*) needman=false;;
	esac
fi
if $needman; then
	cat <<EOH
 
This installation shell script will examine your system and ask you questions
to determine how the dist package should be installed. If you get
stuck on a question, you may use a ! shell escape to start a subshell or
execute a command.  Many of the questions will have default answers in square
brackets; typing carriage return will give you the default.

On some of the questions which ask for file or directory names you are allowed
to use the ~name construct to specify the login directory belonging to "name",
even if you don't have a shell which knows about that.  Questions where this is
allowed will be marked "(~name ok)".

EOH
	rp=''
	dflt='Type carriage return to continue'
	. ./myread
	cat <<'EOH'

The prompter used in this script allows you to use shell variables and
backticks in your answers.  You may use $1, $2, etc...  to refer to the words
in the default answer, as if the default line was a set of arguments given to a
script shell.  This means you may also use $* to repeat the whole default line,
so you do not have to re-type everything to add something to the default.

Everytime there is a substitution, you will have to confirm.  If there is an
error (e.g. an unmatched backtick), the default answer will remain unchanged
and you will be prompted again.

If you are in a hurry, you may run 'Configure -d'.  This will bypass nearly all
the questions and use the computed defaults (or the previous answers if there
was already a config.sh file). Type 'Configure -h' for a list of options.
You may also start interactively and then answer '& -d' at any prompt to turn
on the non-interactive behaviour for the remainder of the execution.

EOH
	. ./myread
	cat <<EOH

Much effort has been expended to ensure that this shell script will run on any
Unix system.  If despite that it blows up on yours, your best bet is to edit
Configure and run it again.  If you can't run Configure for some reason,
you'll have to generate a config.sh file by hand.  Whatever problems you
have, let me (Raphael_Manfredi@pobox.com) know how I blew it.

This installation script affects things in two ways:

1) it may do direct variable substitutions on some of the files included
   in this kit.
2) it builds a config.h file for inclusion in C programs.  You may edit
   any of these files as the need arises after running this script.

If you make a mistake on a question, there is no easy way to back up to it
currently.  The easiest thing to do is to edit config.sh and rerun all the SH
files.  Configure will offer to let you do this before it runs the SH files.

EOH
	dflt='Type carriage return to continue'
	. ./myread
	case "$firsttime" in
	true) echo $user >>../.config/instruct;;
	esac
fi

: script used to emit important warnings
cat >warn <<EOS
$startsh
if test \$# -gt 0; then
	echo "\$@" >msg
else
	cat >msg
fi
echo "*** WARNING:" >&4
sed -e 's/^/*** /' <msg >&4
echo "*** " >&4
cat msg >>config.msg
echo " " >>config.msg
rm -f msg
EOS
chmod +x warn
$eunicefix warn

: find out where common programs are
echo " "
echo "Locating common programs..." >&4
cat <<EOSC >loc
$startsh
case \$# in
0) exit 1;;
esac
thing=\$1
shift
dflt=\$1
shift
for dir in \$*; do
	case "\$thing" in
	.)
	if test -d \$dir/\$thing; then
		echo \$dir
		exit 0
	fi
	;;
	*)
	for thisthing in \$dir/\$thing; do
		: just loop through to pick last item
	done
	if test -f \$thisthing; then
		echo \$thisthing
		exit 0
	elif test -f \$thisthing$_exe; then
		echo \$thisthing
		exit 0
	elif test -f \$dir/\$thing.exe; then
		if test -n "$DJGPP"; then
			echo \$dir/\$thing.exe
		else
			: on Eunice apparently
			echo \$dir/\$thing
		fi
		exit 0
	fi
	;;
	esac
done
echo \$dflt
exit 1
EOSC
chmod +x loc
$eunicefix loc
loclist="
awk
cat
chgrp
chmod
chown
cp
echo
expr
grep
make
mkdir
mv
rm
sed
sort
touch
tr
uniq
"
trylist="
cpp
date
inews
less
line
ln
mail
more
nroff
perl
pg
rmail
sendmail
smail
test
uname
vi
wc
zcat
"
pth=`echo $PATH | sed -e "s/$p_/ /g"`
pth="$pth /sbin /usr/sbin /lib /usr/lib /etc"
for file in $loclist; do
	eval xxx=\$$file
	case "$xxx" in
	/*|?:[\\/]*)
		if test -f "$xxx"; then
			: ok
		else
			./warn "no $xxx -- ignoring your setting for $file." 4>&4
			xxx=`./loc $file $file $pth`
		fi
		;;
	'') xxx=`./loc $file $file $pth`;;
	*) xxx=`./loc $xxx $xxx $pth`;;
	esac
	eval $file=$xxx
	eval _$file=$xxx
	case "$xxx" in
	/*)
		echo $file is in $xxx.
		;;
	?:[\\/]*)
		echo $file is in $xxx.
		;;
	*)
		echo "I don't know where '$file' is, and my life depends on it." >&4
		echo "Go find a public domain implementation or fix your PATH!" >&4
		exit 1
		;;
	esac
done
echo " "
echo "Don't worry if any of the following aren't found..."
say=offhand
for file in $trylist; do
	eval xxx=\$$file
	case "$xxx" in
	/*|?:[\\/]*)
		if test -f "$xxx"; then
			: ok
		else
			./warn "no $xxx -- ignoring your setting for $file." 4>&4
			xxx=`./loc $file $file $pth`
		fi
		;;
	'') xxx=`./loc $file $file $pth`;;
	*) xxx=`./loc $xxx $xxx $pth`;;
	esac
	eval $file=$xxx
	eval _$file=$xxx
	case "$xxx" in
	/*)
		echo $file is in $xxx.
		;;
	?:[\\/]*)
		echo $file is in $xxx.
		;;
	*)
		echo "I don't see $file out there, $say."
		say=either
		;;
	esac
done
case "$egrep" in
egrep$_exe|egrep)
	echo "Substituting grep for egrep."
	egrep=$grep
	_egrep=$_grep
	;;
esac
case "$ln" in
ln$_exe|ln)
	echo "Substituting cp for ln."
	ln=$cp
	_ln=$_cp
	;;
esac
case "$make" in
make$_exe|make)	
	case "$gmake" in
	gmake)
	echo "I can't find make or gmake, and my life depends on it." >&4
	echo "Go find a public domain implementation or fix your PATH setting!" >&4
	exit 1
	;;
	esac
	;;
esac	
case "$gmake" in
gmake$_exe|gmake)	;;
*)
	if test -f "/system/gnu_library/bin/ar.pm"; then
		: Stratus VOS
		echo "Substituting gmake for make."
		make=$gmake
		_make=$_gmake
	fi
	;;
esac
case "$test" in
test|test$_exe)
	echo "Hopefully test is built into your sh."
	test=test
	;;
*)
	if `sh -c "PATH= test true" >/dev/null 2>&1`; then
		echo "Using the test built into your sh."
		test=test
		_test=test
	fi
	;;
esac
case "$echo" in
echo|echo$_exe)
	echo "Hopefully echo is built into your sh."
	echo=echo
	;;
'') ;;
*)
	echo " "
echo "Checking compatibility between $_echo and builtin echo (if any)..." >&4
	$echo $n "hi there$c" >foo1
	echo $n "hi there$c" >foo2
	if cmp foo1 foo2 >/dev/null 2>&1; then
		echo "They are compatible.  In fact, they may be identical."
	else
		case "$n" in
		'-n') n='' c='\c';;
		*) n='-n' c='';;
		esac
		cat <<FOO
They are not compatible!  You are probably running ksh on a non-USG system.
I'll have to use $echo instead of the builtin, since Bourne shell doesn't
have echo built in and we may have to run some Bourne shell scripts.  That
means I'll have to use '$n$c' to suppress newlines now.  Life is ridiculous.

FOO
		$echo $n "The star should be here-->$c"
		$echo "*"
	fi
	$rm -f foo1 foo2
	;;
esac

: generate the trygcc script for later perusal
cat <<EOS >trygcc
$startsh
EOS
cat <<'EOSC' >>trygcc
case "$cc" in
'') ;;
*)  $rm -f try try.*
    $cat >try.c <<EOM
int main(int argc, char *argv[]) {
  (void) argc;
  (void) argv;
  return 0;
}
EOM
    if $cc -o try $ccflags $ldflags try.c; then
       :
    else
        echo "Uh-oh, the C compiler '$cc' doesn't seem to be working." >&4
        despair=yes
        trygcc=yes
        case "$cc" in
        *gcc*) trygcc=no ;;
        esac
        case "`$cc -v -c try.c 2>&1`" in
        *gcc*) trygcc=no ;;
        esac
        if $test X"$trygcc" = Xyes; then
            if gcc -o try -c try.c; then
                echo " "
                echo "You seem to have a working gcc, though." >&4
                rp="Would you like to use it?"
                dflt=y
                if $test -f myread; then
                    . ./myread
                else
                    if $test -f UU/myread; then
                        . ./UU/myread
                    else
                        echo "Cannot find myread, sorry.  Aborting." >&2
                        exit 1
                    fi
                fi  
                case "$ans" in
                [yY]*) cc=gcc; ccname=gcc; ccflags=''; despair=no;
                       $cat *.cbu >checktmp 2>/dev/null
                       if $contains ccflags checktmp >/dev/null; then
                           ./warn 4>&4 <<EOM 
Any previous setting of the C compiler flags has been lost.
It may be necessary to pass -Dcc=gcc to Configure right away.
EOM
                       fi;;
                esac
            fi
        fi
    fi
    $rm -f try try.*
    ;;
esac
EOSC

: generate the checkcc script for later perusal
cat <<EOS >checkcc
$startsh
EOS
cat <<'EOSC' >>checkcc
case "$cc" in        
'') ;;
*)  $rm -f try try.*              
    $cat >try.c <<EOM
int main(int argc, char *argv[]) {
  (void) argc;
  (void) argv;
  return 0;
}
EOM
    if $cc -o try $ccflags $ldflags try.c; then
       :
    else
        if $test X"$despair" = Xyes; then
           echo "Uh-oh, the C compiler '$cc' doesn't seem to be working." >&4
        fi
        $cat >&4 <<EOM         
You need to find a working C compiler.
Either (purchase and) install the C compiler supplied by your OS vendor,
or for a free C compiler try http://gcc.gnu.org/
I cannot continue any further, aborting.
EOM
        exit 1
    fi
    $rm -f try try.*
    ;;
esac
EOSC

: determine whether symbolic links are supported
echo " "
$rm -f blurfl sym
$touch blurfl
if $ln -s blurfl sym > /dev/null 2>&1 && $test -f sym; then
	echo "Symbolic links are supported." >&4
	lns="$ln -s"
else
	echo "Symbolic links are NOT supported." >&4
	lns="$ln"
fi
$rm -f blurfl sym

: determine whether symbolic links are supported
echo " "
case "$lns" in
*"ln"*" -s")
	echo "Checking how to test for symbolic links..." >&4
	$lns blurfl sym
	if $test "X$issymlink" = X; then
		case "$newsh" in
		'') sh     -c "PATH= test -h sym" >/dev/null 2>&1 ;;
		*)  $newsh -c "PATH= test -h sym" >/dev/null 2>&1 ;;
		esac
		if test $? = 0; then
			issymlink="test -h"
		else
			echo "Your builtin 'test -h' may be broken." >&4
			case "$test" in
			/*)	;;
			*)	pth=`echo $PATH | sed -e "s/$p_/ /g"`
				for p in $pth
				do
					if test -f "$p/$test"; then
						test="$p/$test"
						break
					fi
				done
				;;
			esac
			case "$test" in
			/*)
				echo "Trying external '$test -h'." >&4
				issymlink="$test -h"
				if $test ! -h sym >/dev/null 2>&1; then
					echo "External '$test -h' is broken, too." >&4
					issymlink=''
				fi
				;;
			*)	issymlink='' ;;
			esac
		fi		
	fi
	if $test "X$issymlink" = X; then
		if $test -L sym 2>/dev/null; then
			issymlink="$test -L"
			echo "The builtin '$test -L' worked." >&4
		fi
	fi
	if $test "X$issymlink" != X; then
		echo "You can test for symbolic links with '$issymlink'." >&4
	else
		echo "I do not know how you can test for symbolic links." >&4
	fi
	$rm -f blurfl sym
	;;
*)	echo "No symbolic links, so not testing for their testing..." >&4
	;;
esac

: define absolute package source directory
case "$src" in
/*) pkgsrc=$src;;
*) pkgsrc=`cd $rsrc; pwd`;;
esac

: Duplicate the tree with symbolic links if -Dmksymlinks was supplied
case "$mksymlinks" in
$define|true|[yY]*)
	echo " "
	case "$src" in
	''|'.')	echo "Cannot create symlinks in the original directory." >&4
		exit 1
		;;
	*)	case "$lns:$issymlink" in
		*"ln"*" -s:"*"test -"?)
			echo "Creating the symbolic links..." >&4
			echo "(First creating the subdirectories...)" >&4
			cd ..
			awk '{print $1}' $src/MANIFEST | grep / | sed 's:/[^/]*$::' | \
				sort -u | while true
			do
				read dir
				test -z "$dir" && break
				./UU/mkdirp $dir 2>/dev/null
				if test -d $dir; then
					: ok
				else
					echo "Failed to create '$dir'.  Aborting." >&4
					exit 1
				fi
			done
			echo "(Now creating the symlinks...)" >&4
			awk '{print $1}' $src/MANIFEST | while true; do
				read filename
				test -z "$filename" && break
				if test -f $filename; then
					if $issymlink $filename; then
						rm -f $filename
					fi
				fi
				if test -f $filename; then
					echo "$filename already exists, not symlinking."
				else
					ln -s $pkgsrc/$filename $filename
				fi
			done
			echo "(Checking current directory...)" >&4
			cd UU
			awk '$1 !~ /PACK[A-Z]+/ {print $1}' "$rsrc/MANIFEST" | \
				(split -l 50 2>/dev/null || split -50)
			rm -f missing
			tmppwd=`pwd`
			for filelist in x??; do
				(cd ..; ls `cat "$tmppwd/$filelist"` \
					>/dev/null 2>>"$tmppwd/missing")
			done
			if test -s missing; then
				echo "Failed duplication of source tree.  Aborting." >&4
				exit 1
			fi
			;;
		*)	echo "(I cannot figure out how to do symbolic links, ignoring!)" >&4
			;;
		esac
		;;
	esac
	;;
esac

: see whether [:lower:] and [:upper:] are supported character classes
echo " "
case "`echo AbyZ | LC_ALL=C $tr '[:lower:]' '[:upper:]' 2>/dev/null`" in
ABYZ)
	echo "Good, your tr supports [:lower:] and [:upper:] to convert case." >&4
	up='[:upper:]'
	low='[:lower:]'
	;;
*)	# There is a discontinuity in EBCDIC between 'I' and 'J'
        # (0xc9 and 0xd1), therefore that is a nice testing point.
        if test "X$up" = X -o "X$low" = X; then
	    case "`echo IJ | LC_ALL=C $tr '[I-J]' '[i-j]' 2>/dev/null`" in
	    ij) up='[A-Z]'
	        low='[a-z]'
		;;
	    esac
        fi
	if test "X$up" = X -o "X$low" = X; then
	    case "`echo IJ | LC_ALL=C $tr I-J i-j 2>/dev/null`" in
	    ij) up='A-Z'
		low='a-z'
		;;
	    esac
        fi
	if test "X$up" = X -o "X$low" = X; then
	    case "`echo IJ | od -x 2>/dev/null`" in
	    *C9D1*|*c9d1*)
		echo "Hey, this might be EBCDIC." >&4
		if test "X$up" = X -o "X$low" = X; then
		    case "`echo IJ | \
				LC_ALL=C $tr '[A-IJ-RS-Z]' '[a-ij-rs-z]' 2>/dev/null`" in
		    ij) up='[A-IJ-RS-Z]'
		        low='[a-ij-rs-z]'
			;;
		    esac
		fi
		if test "X$up" = X -o "X$low" = X; then
		    case "`echo IJ | LC_ALL=C $tr A-IJ-RS-Z a-ij-rs-z 2>/dev/null`" in
		    ij) up='A-IJ-RS-Z'
		        low='a-ij-rs-z'
			;;
		    esac
		fi
		;;
	    esac
	fi
esac
case "`echo IJ | LC_ALL=C $tr \"$up\" \"$low\" 2>/dev/null`" in
ij)
    echo "Using $up and $low to convert case." >&4
    ;;
*)
    echo "I don't know how to translate letters from upper to lower case." >&4
    echo "Your tr is not acting any way I know of." >&4
    exit 1
    ;;
esac
: set up the translation script tr, must be called with ./tr of course
cat >tr <<EOSC
$startsh
case "\$1\$2" in
'[A-Z][a-z]') LC_ALL=C exec $tr '$up' '$low';;
'[a-z][A-Z]') LC_ALL=C exec $tr '$low' '$up';;
esac
LC_ALL=C exec $tr "\$@"
EOSC
chmod +x tr
$eunicefix tr

: setup for possible cross-compilation
run=''
to=:
from=:
usecrosscompile='undef'
targetarch=''
case "$usecrosscompile" in
$define|true|[yY]*)
	echo "Cross-compilation is not supported for this package." >&4
	exit 1
	;;
esac

: Determine the name of the machine
myuname=`$uname -a 2>/dev/null`
$test -z "$myuname" && myuname=`hostname 2>/dev/null`
myuname=`echo $myuname | $sed -e 's/^[^=]*=//' -e 's/\///g' | \
	./tr '[A-Z]' '[a-z]' | $tr $trnl ' '`
newmyuname="$myuname"
has_uname=
$test -f "$uname" && has_uname=y

: Guessing of the OS name -- half the following guesses are probably wrong...
: If you have better tests or hints, please send them to the metaconfig
: authors and to Raphael_Manfredi@pobox.com
$test -f /irix && osname=irix
$test -f /xenix && osname=sco_xenix
$test -f /dynix && osname=dynix
$test -f /dnix && osname=dnix
$test -f /lynx.os && osname=lynxos
$test -f /unicos && osname=unicos && osvers=`$uname -r`
$test -f /unicosmk && osname=unicosmk && osvers=`$uname -r`
$test -f /unicosmk.ar && osname=unicosmk && osvers=`$uname -r`
$test -f /bin/mips && /bin/mips && osname=mips
$test -d /NextApps && set X `hostinfo | $grep 'NeXT Mach.*:' | \
	$sed -e 's/://' -e 's/\./_/'` && osname=next && osvers=$4
$test -d /usr/apollo/bin && osname=apollo
$test -f /etc/saf/_sactab && osname=svr4
$test -d /usr/include/minix && osname=minix
$test -f /system/gnu_library/bin/ar.pm && osname=vos
if $test -d /MachTen -o -d /MachTen_Folder; then
	osname=machten
	if $test -x /sbin/version; then
		osvers=`/sbin/version | $awk '{print $2}' |
		$sed -e 's/[A-Za-z]$//'`
	elif $test -x /usr/etc/version; then
		osvers=`/usr/etc/version | $awk '{print $2}' |
		$sed -e 's/[A-Za-z]$//'`
	else
		osvers="$2.$3"
	fi
fi
$test -f /sys/posix.dll &&
	$test -f /usr/bin/what &&
	set X `/usr/bin/what /sys/posix.dll` &&
	$test "$3" = UWIN &&
	osname=uwin &&
	osvers="$5"
if $test "X$has_uname" != X; then
	set X $myuname
	shift
	case "$5" in
	fps*) osname=fps ;;
	mips*)
		case "$4" in
		umips) osname=umips ;;
		*) osname=mips ;;
		esac;;
	[23]100) osname=mips ;;
	next*) osname=next ;;
	i386*)
		tmp=`/bin/uname -X 2>/dev/null|awk '/3\.2v[45]/{ print $(NF) }'`
		if $test "$tmp" != "" -a "$3" = "3.2" -a -f '/etc/systemid'; then
			osname='sco'
			osvers=$tmp
		elif $test -f /etc/kconfig; then
			osname=isc
			if $test "$lns" = "$ln -s"; then
				osvers=4
			elif $contains _SYSV3 /usr/include/stdio.h > /dev/null 2>&1 ; then
				osvers=3
			elif $contains _POSIX_SOURCE /usr/include/stdio.h > /dev/null 2>&1
			then
				osvers=2
			fi
		fi
		tmp=''
		;;
	pc*)
		if $test -n "$DJGPP"; then
			osname=dos
			osvers=djgpp
		fi
		;;
	esac
	case "$1" in
	aix) osname=aix
		tmp=`( (oslevel) 2>/dev/null || echo "not found") 2>&1`
		case "$tmp" in
		'not found') osvers="$4"."$3" ;;
		'<3240'|'<>3240') osvers=3.2.0 ;;
		'=3240'|'>3240'|'<3250'|'<>3250') osvers=3.2.4 ;;
		'=3250'|'>3250') osvers=3.2.5 ;;
		*) osvers=$tmp;;
		esac
		;;
	bsd386) osname=bsd386
		osvers=`$uname -r`
		;;
	cygwin*) osname=cygwin
		osvers=`echo "$3" | sed -e 's/\(.*\)(.*/\1/'`
		;;
	mingw*) osname=mingw
		osvers=`echo "$3" | sed -e 's/\(.*\)(.*/\1/'`
		;;
	*dc.osx) osname=dcosx
		osvers="$3"
		;;
	dnix) osname=dnix
		osvers="$3"
		;;
	domainos) osname=apollo
		osvers="$3"
		;;
	dgux) osname=dgux 
		osvers="$3"
		;;
	dynixptx*) osname=dynixptx
		osvers=`echo "$4"|sed 's/^v//'`
		;;
	freebsd) osname=freebsd 
		osvers="$3" ;;
	genix) osname=genix ;;
	hp*) osname=hpux 
		osvers=`echo "$3" | $sed 's,.*\.\([0-9]*\.[0-9]*\),\1,'`
		;;
	irix*) osname=irix
		case "$3" in
		4*) osvers=4 ;;
		5*) osvers=5 ;;
		*)	osvers="$3" ;;
		esac
		;;
	linux) osname=linux
		case "$3" in
		*)	osvers="$3" ;;
		esac
		;;
	MiNT) osname=mint
		;;
	netbsd*) osname=netbsd
		osvers="$3"
		;;
	news-os) osvers="$3"
		case "$3" in
		4*) osname=newsos4 ;;
		*) osname=newsos ;;
		esac
		;;
	next*) osname=next ;;
	nonstop-ux) osname=nonstopux ;;
	openbsd) osname=openbsd
				osvers="$3"
				;;
	POSIX-BC | posix-bc ) osname=posix-bc
		osvers="$3"
		;;
	powerux | power_ux | powermax_os | powermaxos | \
	powerunix | power_unix) osname=powerux
		osvers="$3"
		;;
	qnx) osname=qnx
		osvers="$4"
		;;
	solaris) osname=solaris
		case "$3" in
		5*) osvers=`echo $3 | $sed 's/^5/2/g'` ;;
		*)	osvers="$3" ;;
		esac
		;;
	sunos) osname=sunos
		case "$3" in
		5*) osname=solaris
			osvers=`echo $3 | $sed 's/^5/2/g'` ;;
		*)	osvers="$3" ;;
		esac
		;;
	titanos) osname=titanos
		case "$3" in
		1*) osvers=1 ;;
		2*) osvers=2 ;;
		3*) osvers=3 ;;
		4*) osvers=4 ;;
		*)	osvers="$3" ;;
		esac
		;;
	ultrix) osname=ultrix
		osvers="$3"
		;;
	osf1|mls+)	case "$5" in
		alpha)
			osname=dec_osf
			osvers=`sizer -v | awk '{print $3}' | \
				./tr '[A-Z]' '[a-z]' | sed 's/^[xvt]//'`
			case "$osvers" in
			[1-9].[0-9]*) ;;
			*) osvers=`echo "$3" | sed 's/^[xvt]//'` ;;
			esac
			;;
		hp*)	osname=hp_osf1	;;
		mips)	osname=mips_osf1 ;;
		esac
		;;
	unixware) osname=svr5
		osvers="$4"
		;;
	uts)	osname=uts
		osvers="$3"
		;;
	vos) osvers="$3"
		;;
	$2) case "$osname" in
		*isc*) ;;
		*freebsd*) ;;
		svr*)
			: svr4.x or possibly later
			case "svr$3" in	
			${osname}*)
				osname=svr$3
				osvers=$4
				;;
			esac
			case "$osname" in
			svr4.0)
				: Check for ESIX
				if $test -f /stand/boot ; then
					eval `$grep '^INITPROG=[a-z/0-9]*$' /stand/boot`
					if $test -n "$INITPROG" -a -f "$INITPROG"; then
						isesix=`strings -a $INITPROG | \
							$grep 'ESIX SYSTEM V/386 Release 4.0'`
						if $test -n "$isesix"; then
							osname=esix4
						fi
					fi
				fi
				;;
			esac
			;;
		*)	if $test -f /etc/systemid; then
				osname=sco
				set `echo $3 | $sed 's/\./ /g'` $4
				if $test -f $src/hints/sco_$1_$2_$3.sh; then
					osvers=$1.$2.$3
				elif $test -f $src/hints/sco_$1_$2.sh; then
					osvers=$1.$2
				elif $test -f $src/hints/sco_$1.sh; then
					osvers=$1
				fi
			else
				case "$osname" in
				'') : Still unknown.  Probably a generic Sys V.
					osname="sysv"
					osvers="$3"
					;;
				esac
			fi
			;;
		esac
		;;
	*)	case "$osname" in
		'') : Still unknown.  Probably a generic BSD.
			osname="$1"
			osvers="$3"
			;;
		esac
		;;
	esac
else
	if $test -f /vmunix -a -f $src/hints/news_os.sh; then
		(what /vmunix | UU/tr '[A-Z]' '[a-z]') > UU/kernel.what 2>&1
		if $contains news-os UU/kernel.what >/dev/null 2>&1; then
			osname=news_os
		fi
		$rm -f UU/kernel.what
	elif $test -d c:/.; then
		set X $myuname
		osname=os2
		osvers="$5"
	fi
fi

: Try to determine whether config.sh was made on this system
case "$config_sh" in
'')
dflt=n
case "$knowitall" in
'')
	if test -f ../config.sh; then
		if $contains myuname= ../config.sh >/dev/null 2>&1; then
			eval "`$grep myuname= ../config.sh`"
		fi
		if test "X$myuname" = "X$newmyuname"; then
			dflt=y
		fi
	fi
	;;
*) dflt=y;;
esac

saved_osname="$osname"
saved_osvers="$osvers"
saved_libswanted="$libswanted"
tmp_n="$n"
tmp_c="$c"
tmp_sh="$sh"

: Get old answers from config file if it was generated on the same system
hint=default
if $test -f ../config.sh; then
	echo " "
	rp="I see a config.sh file.  Shall I use it to set the defaults?"
	. ./myread
	case "$ans" in
	n*|N*) echo "OK, I'll ignore it."
		mv ../config.sh ../config.sh.old
		myuname="$newmyuname"
		;;
	*)  echo "Fetching default answers from your old config.sh file..." >&4
		. ../config.sh
		cp ../config.sh .
		hint=previous
		case "$dflt" in
		n)
			echo " "
			rp="Do you want further invocations to use these defaults?"
			. ./myread
			case "$ans" in
			y*|Y*) myuname="$newmyuname";;
			esac
			;;
		esac
		;;
	esac
fi
;;
*)
	echo " "
	echo "Fetching default answers from $config_sh..." >&4
	cd ..
	cp $config_sh config.sh 2>/dev/null
	chmod +w config.sh
	. ./config.sh
	cd UU
	cp ../config.sh .
	hint=previous
	;;
esac
case "$sh" in
'') sh="$tmp_sh" ;;
esac
$test "$override" && . ./optdef.sh

: Restore computed paths
for file in $loclist $trylist; do
	eval $file="\$_$file"
done

osname="$saved_osname"
osvers="$saved_osvers"
n="$tmp_n"
c="$tmp_c"

case "$libswanted" in
"$saved_libswanted") ;;
*) libs='';;
esac
libswanted="$saved_libswanted"

. ./checkcc
case "$targetarch" in
'') ;;
*)  hostarch=$osname
	osname=`echo $targetarch|sed 's,^[^-]*-,,'`
	osvers=''
	;;
esac

: Process their -A options
. ./posthint.sh

: Ask them to confirm the OS name
cat << EOM

Configure uses the operating system name and version to set some defaults.
The default value is probably right if the name rings a bell. Otherwise,
since spelling matters for me, either accept the default or answer "none"
to leave it blank.

EOM
case "$osname" in
	''|' ')
		case "$hintfile" in
		''|' '|none) dflt=none ;;
		*)  dflt=`echo $hintfile | $sed -e 's/\.sh$//' -e 's/_.*$//'` ;;
		esac
		;;
	*) dflt="$osname" ;;
esac
rp="Operating system name?"
. ./myread
case "$ans" in
none)  osname='' ;;
*) osname=`echo "$ans" | $sed -e 's/[ 	][	]*/_/g' | ./tr '[A-Z]' '[a-z]'`;;
esac
echo " "
case "$osvers" in
	''|' ')
		case "$hintfile" in
		''|' '|none) dflt=none ;;
		*)	dflt=`echo $hintfile | $sed -e 's/\.sh$//' -e 's/^[^_]*//'`
			dflt=`echo $dflt | $sed -e 's/^_//' -e 's/_/./g'`
			case "$dflt" in
			''|' ') dflt=none ;;
			esac
			;;
		esac
		;;
	*) dflt="$osvers" ;;
esac
rp="Operating system version?"
. ./myread
case "$ans" in
none)  osvers='' ;;
*) osvers="$ans" ;;
esac

: who configured the system
cf_time=`LC_ALL=C; LANGUAGE=C; export LC_ALL; export LANGUAGE; $date 2>&1`
cf_by=`(logname) 2>/dev/null`
case "$cf_by" in
"")
	cf_by=`(whoami) 2>/dev/null`
	case "$cf_by" in
	"") cf_by=unknown ;;
	esac ;;
esac

: allow them to override the AFS root
case "$afsroot" in
'')	afsroot=/afs ;;
*)	afsroot=$afsroot ;;
esac

: is AFS running?
echo " "
case "$afs" in
$define|true)	afs=true ;;
$undef|false)	afs=false ;;
*)	if $test -d $afsroot; then
		afs=true
	else
		afs=false
	fi
	;;
esac
if $afs; then
	echo "AFS may be running... I'll be extra cautious then..." >&4
else
	echo "AFS does not seem to be running..." >&4
fi

: determine where manual pages are on this system
echo " "
case "$sysman" in
'') 
	syspath='/usr/share/man/man1 /usr/man/man1'
	syspath="$syspath /usr/man/mann /usr/man/manl /usr/man/local/man1"
	syspath="$syspath /usr/man/u_man/man1 /usr/share/man/man1"
	syspath="$syspath /usr/catman/u_man/man1 /usr/man/l_man/man1"
	syspath="$syspath /usr/local/man/u_man/man1 /usr/local/man/l_man/man1"
	syspath="$syspath /usr/man/man.L /local/man/man1 /usr/local/man/man1"
	sysman=`./loc . /usr/man/man1 $syspath`
	;;
esac
if $test -d "$sysman"; then
	echo "System manual is in $sysman." >&4
else
	echo "Could not find manual pages in source form." >&4
fi

: decide how portable to be
case "$d_portable" in
"$define") dflt=y;;
*)	dflt=n;;
esac
$cat <<'EOH'
 
I can set things up so that your shell scripts and binaries are more portable,
at what may be a noticable cost in performance.  In particular, if you
ask to be portable, the following happens:

     1) Shell scripts will rely on the PATH variable rather than using
	the paths derived above.
     2) ~username interpretations will be done at run time rather than
	by Configure.

EOH
rp="Do you expect to run these scripts and binaries on multiple machines?"
. ./myread
case "$ans" in
	y*) d_portable="$define"
	;;
	*)  d_portable="$undef" ;;
esac

: set up shell script to do ~ expansion
cat >filexp <<EOSS
$startsh
: expand filename
case "\$1" in
 ~/*|~)
	echo \$1 | $sed "s|~|\${HOME-\$LOGDIR}|"
	;;
 ~*)
	if $test -f /bin/csh; then
		/bin/csh -f -c "glob \$1"
		failed=\$?
		echo ""
		exit \$failed
	else
		name=\`$expr x\$1 : '..\([^/]*\)'\`
		dir=\`$sed -n -e "/^\${name}:/{s/^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:\([^:]*\).*"'\$'"/\1/" -e p -e q -e '}' </etc/passwd\`
		if $test ! -d "\$dir"; then
			me=\`basename \$0\`
			echo "\$me: can't locate home directory for: \$name" >&2
			exit 1
		fi
		case "\$1" in
		*/*)
			echo \$dir/\`$expr x\$1 : '..[^/]*/\(.*\)'\`
			;;
		*)
			echo \$dir
			;;
		esac
	fi
	;;
*)
	echo \$1
	;;
esac
EOSS
chmod +x filexp
$eunicefix filexp

: now set up to get a file name
cat <<EOS >getfile
$startsh
EOS
cat <<'EOSC' >>getfile
tilde=''
fullpath=''
already=''
skip=''
none_ok=''
exp_file=''
nopath_ok=''
orig_rp="$rp"
orig_dflt="$dflt"
case "$gfpth" in
'') gfpth='.' ;;
esac

case "$fn" in
*\(*)
	: getfile will accept an answer from the comma-separated list
	: enclosed in parentheses even if it does not meet other criteria.
	expr "$fn" : '.*(\(.*\)).*' | $tr ',' $trnl >getfile.ok
	fn=`echo $fn | sed 's/(.*)//'`
	;;
esac

case "$fn" in
*:*)
	loc_file=`expr $fn : '.*:\(.*\)'`
	fn=`expr $fn : '\(.*\):.*'`
	;;
esac

case "$fn" in
*~*) tilde=true;;
esac
case "$fn" in
*/*) fullpath=true;;
esac
case "$fn" in
*+*) skip=true;;
esac
case "$fn" in
*n*) none_ok=true;;
esac
case "$fn" in
*e*) exp_file=true;;
esac
case "$fn" in
*p*) nopath_ok=true;;
esac

case "$fn" in
*f*) type='File';;
*d*) type='Directory';;
*l*) type='Locate';;
esac

what="$type"
case "$what" in
Locate) what='File';;
esac

case "$exp_file" in
'')
	case "$d_portable" in
	"$define") ;;
	*) exp_file=true;;
	esac
	;;
esac

cd ..
while test "$type"; do
	redo=''
	rp="$orig_rp"
	dflt="$orig_dflt"
	case "$tilde" in
	true) rp="$rp (~name ok)";;
	esac
	. UU/myread
	if test -f UU/getfile.ok && \
		$contains "^$ans\$" UU/getfile.ok >/dev/null 2>&1
	then
		value="$ans"
		ansexp="$ans"
		break
	fi
	case "$ans" in
	none)
		value=''
		ansexp=''
		case "$none_ok" in
		true) type='';;
		esac
		;;
	*)
		case "$tilde" in
		'') value="$ans"
			ansexp="$ans";;
		*)
			value=`UU/filexp $ans`
			case $? in
			0)
				if test "$ans" != "$value"; then
					echo "(That expands to $value on this system.)"
				fi
				;;
			*) value="$ans";;
			esac
			ansexp="$value"
			case "$exp_file" in
			'') value="$ans";;
			esac
			;;
		esac
		case "$fullpath" in
		true)
			case "$ansexp" in
			/*) value="$ansexp" ;;
			[a-zA-Z]:/*) value="$ansexp" ;;
			[a-zA-Z]:\\*) value="$ansexp" ;;
			*)
				redo=true
				case "$already" in
				true)
				echo "I shall only accept a full path name, as in /bin/ls." >&4
				echo "Use a ! shell escape if you wish to check pathnames." >&4
					;;
				*)
				echo "Please give a full path name, starting with slash." >&4
					case "$tilde" in
					true)
				echo "Note that using ~name is ok provided it expands well." >&4
						already=true
						;;
					esac
				esac
				;;
			esac
			;;
		esac
		case "$redo" in
		'')
			case "$type" in
			File)
				for fp in $gfpth; do
					if test "X$fp" = X.; then
					    pf="$ansexp"
					else    
					    pf="$fp/$ansexp"
					fi
					if test -f "$pf"; then
						type=''
					elif test -r "$pf" || (test -h "$pf") >/dev/null 2>&1
					then
						echo "($value is not a plain file, but that's ok.)"
						type=''
					fi
					if test X"$type" = X; then
					    value="$pf"
					    break
					fi
				done
				;;
			Directory)
				for fp in $gfpth; do
					if test "X$fp" = X.; then
					    dir="$ans"
					    direxp="$ansexp"
					else    
					    dir="$fp/$ansexp"
					    direxp="$fp/$ansexp"
					fi
					if test -d "$direxp"; then
						type=''
						value="$dir"
						break
					fi
				done
				;;
			Locate)
				if test -d "$ansexp"; then
					echo "(Looking for $loc_file in directory $value.)"
					value="$value/$loc_file"
					ansexp="$ansexp/$loc_file"
				fi
				if test -f "$ansexp"; then
					type=''
				fi
				case "$nopath_ok" in
				true)	case "$value" in
					*/*) ;;
					*)	echo "Assuming $value will be in people's path."
						type=''
						;;
					esac
					;;
				esac
				;;
			esac

			case "$skip" in
			true) type='';
			esac

			case "$type" in
			'') ;;
			*)
				if test "$fastread" = yes; then
					dflt=y
				else
					dflt=n
				fi
				rp="$what $value doesn't exist.  Use that name anyway?"
				. UU/myread
				dflt=''
				case "$ans" in
				y*) type='';;
				*) echo " ";;
				esac
				;;
			esac
			;;
		esac
		;;
	esac
done
cd UU
ans="$value"
rp="$orig_rp"
dflt="$orig_dflt"
rm -f getfile.ok
test "X$gfpthkeep" != Xy && gfpth=""
EOSC

: determine root of directory hierarchy where package will be installed.
case "$prefix" in
'')
	dflt=`./loc . /usr/local /usr/local /local /opt /usr`
	;;
*)
	dflt="$prefix"
	;;
esac
$cat <<EOM

By default, $package will be installed in $dflt/bin, manual
pages under $dflt/man, etc..., i.e. with $dflt as prefix for
all installation directories. Typically set to /usr/local, but you
may choose /usr if you wish to install $package among your system
binaries. If you wish to have binaries under /bin but manual pages
under /usr/local/man, that's ok: you will be prompted separately
for each of the installation directories, the prefix being only used
to set the defaults.

EOM
fn=d~
rp='Installation prefix to use?'
. ./getfile
oldprefix=''
case "$prefix" in
'') ;;
*)
	case "$ans" in
	"$prefix") ;;
	*) oldprefix="$prefix";;
	esac
	;;
esac
prefix="$ans"
prefixexp="$ansexp"

: set the prefixit variable, to compute a suitable default value
prefixit='case "$3" in
""|none)
	case "$oldprefix" in
	"") eval "$1=\"\$$2\"";;
	*)
		case "$3" in
		"") eval "$1=";;
		none)
			eval "tp=\"\$$2\"";
			case "$tp" in
			""|" ") eval "$1=\"\$$2\"";;
			*) eval "$1=";;
			esac;;
		esac;;
	esac;;
*)
	eval "tp=\"$oldprefix-\$$2-\""; eval "tp=\"$tp\"";
	case "$tp" in
	--|/*--|\~*--) eval "$1=\"$prefix/$3\"";;
	/*-$oldprefix/*|\~*-$oldprefix/*)
		eval "$1=\`echo \$$2 | sed \"s,^$oldprefix,$prefix,\"\`";;
	*) eval "$1=\"\$$2\"";;
	esac;;
esac'

: set the prefixup variable, to restore leading tilda escape
prefixup='case "$prefixexp" in
"$prefix") ;;
*) eval "$1=\`echo \$$1 | sed \"s,^$prefixexp,$prefix,\"\`";;
esac'

: determine where manual pages go
set mansrc mansrc none
eval $prefixit
$cat <<EOM

$spackage has manual pages available in source form.
EOM
case "$nroff" in
nroff)
	echo "However, you don't have nroff, so they're probably useless to you."
	case "$mansrc" in
	'') mansrc="none";;
	esac;;
esac
echo "If you don't want the manual sources installed, answer 'none'."
case "$mansrc" in
'')
	lookpath="$prefixexp/share/man/man1 $prefixexp/man/man1"
	lookpath="$lookpath $prefixexp/man/u_man/man1 $prefixexp/man/l_man/man1"
	lookpath="$lookpath /usr/local/man/man1 /opt/man/man1 /usr/man/manl"
	lookpath="$lookpath /usr/share/man/man1 /usr/local/share/man/man1"
	lookpath="$lookpath /usr/man/local/man1 /usr/man/l_man/man1"
	lookpath="$lookpath /usr/local/man/u_man/man1 /usr/local/man/l_man/man1"
	lookpath="$lookpath /usr/man/man.L"
	mansrc=`./loc . $prefixexp/man/man1 $lookpath`
	if $test -d "$mansrc"; then
		dflt="$mansrc"
	else
		dflt="$sysman"
	fi
	set dflt
	eval $prefixup
	;;
' ') dflt=none;;
*)  dflt="$mansrc"
	;;
esac
echo " "
fn=dn~
rp='Where do the manual pages (source) go?'
. ./getfile
if test "X$mansrcexp" != "X$ansexp"; then
	installmansrc=''
fi
mansrc="$ans"
mansrcexp="$ansexp"
case "$mansrc" in
'') mansrc=' '
	installmansrc='';;
esac
if $afs && $test "$mansrc"; then
	$cat <<EOM

Since you are running AFS, I need to distinguish the directory in which
manual pages reside from the directory in which they are installed (and from
which they are presumably copied to the former directory by occult means).

EOM
	case "$installmansrc" in
	'') dflt=`echo $mansrcexp | sed 's#^/afs/#/afs/.#'`;;
	*) dflt="$installmansrc";;
	esac
	fn=de~
	rp='Where will man pages be installed?'
	. ./getfile
	installmansrc="$ans"
else
	installmansrc="$mansrcexp"
fi

case "$mansrc" in
' ') manext='0';;
*l) manext=l;;
*n) manext=n;;
*o) manext=l;;
*p) manext=n;;
*C) manext=C;;
*L) manext=L;;
*L1) manext=L1;;
*) manext=1;;
esac

: determine where private executables go
set dflt privlib lib/$package
eval $prefixit
$cat <<EOM

There are some auxiliary files for $package that need to be put into a
private library directory that is accessible by everyone.

EOM
fn=d~+
rp='Pathname where the private library files will reside?'
. ./getfile
if $test "X$privlibexp" != "X$ansexp"; then
	installprivlib=''
fi
privlib="$ans"
privlibexp="$ansexp"
if $afs; then
	$cat <<EOM

Since you are running AFS, I need to distinguish the directory in which
private files reside from the directory in which they are installed (and from
which they are presumably copied to the former directory by occult means).

EOM
	case "$installprivlib" in
	'') dflt=`echo $privlibexp | sed 's#^/afs/#/afs/.#'`;;
	*) dflt="$installprivlib";;
	esac
	fn=de~
	rp='Where will private files be installed?'
	. ./getfile
	installprivlib="$ans"
else
	installprivlib="$privlibexp"
fi

: determine where public executable scripts go
set scriptdir scriptdir
eval $prefixit
case "$scriptdir" in
'')
	dflt="$bin"
	: guess some guesses
	$test -d /usr/share/scripts && dflt=/usr/share/scripts
	$test -d /usr/share/bin && dflt=/usr/share/bin
	$test -d /usr/local/script && dflt=/usr/local/script
	$test -d $prefixexp/script && dflt=$prefixexp/script
	set dflt
	eval $prefixup
	;;
*)  dflt="$scriptdir"
	;;
esac
$cat <<EOM
 
Some installations have a separate directory just for executable scripts so
that they can mount it across multiple architectures but keep the scripts in
one spot.  You might, for example, have a subdirectory of /usr/share for this.
Or you might just lump your scripts in with all your other executables.
 
EOM
fn=d~
rp='Where do you keep publicly executable scripts?'
. ./getfile
if $test "X$ansexp" != "X$scriptdirexp"; then
	installscript=''
fi
scriptdir="$ans"
scriptdirexp="$ansexp"
if $afs; then
	$cat <<EOM

Since you are running AFS, I need to distinguish the directory in which
scripts reside from the directory in which they are installed (and from
which they are presumably copied to the former directory by occult means).

EOM
	case "$installscript" in
	'') dflt=`echo $scriptdirexp | sed 's#^/afs/#/afs/.#'`;;
	*) dflt="$installscript";;
	esac
	fn=de~
	rp='Where will public scripts be installed?'
	. ./getfile
	installscript="$ans"
else
	installscript="$scriptdirexp"
fi

: preserve RCS keywords in files with variable substitution, grrr
Header='$Header'
Id='$Id'
Log='$Log'

: Define several unixisms.
: Hints files or command line option can be used to override them.
case "$_a" in
'') _a='.a';;
esac
case "$_o" in
'') _o='.o';;
esac

: set the base revision
baserev=3.5

: make some quick guesses about what we are up against
echo " "
$echo $n "Hmm...  $c"
echo exit 1 >bsd
echo exit 1 >usg
echo exit 1 >v7
echo exit 1 >osf1
echo exit 1 >eunice
echo exit 1 >xenix
echo exit 1 >venix
echo exit 1 >os2
echo exit 1 >gnu
echo exit 1 >linux
echo exit 1 >dos
echo exit 1 >windows
d_bsd="$undef"
d_linux="$undef"
d_dos="$undef"
d_os2="$undef"
d_windows="$undef"
$cat /usr/include/signal.h /usr/include/sys/signal.h >foo 2>/dev/null
if test -f /osf_boot || $contains 'OSF/1' /usr/include/ctype.h >/dev/null 2>&1
then
	echo "Looks kind of like an OSF/1 system, but we'll see..."
	echo exit 0 >osf1
elif test `echo abc | $tr a-z A-Z` = Abc ; then
	xxx=`./loc addbib blurfl $pth`
	if $test -f $xxx; then
	echo "Looks kind of like a USG system with BSD features, but we'll see..."
		echo exit 0 >bsd
		echo exit 0 >usg
	else
		if $contains SIGTSTP foo >/dev/null 2>&1 ; then
			echo "Looks kind of like an extended USG system, but we'll see..."
		else
			echo "Looks kind of like a USG system, but we'll see..."
		fi
		echo exit 0 >usg
	fi
elif $contains SIGTSTP foo >/dev/null 2>&1 ; then
	echo "Looks kind of like a BSD system, but we'll see..."
	d_bsd="$define"
	echo exit 0 >bsd
elif
	$rm --version 2>/dev/null >foo;
	$contains "Free Software Foundation" foo >/dev/null
then
	xxx=`uname`
	echo exit 0 >gnu
	echo "Looks kind of like a GNU/$xxx system, but we'll see..."
	if $test X$xxx = XLinux; then
		d_linux="$define"
		echo exit 0 >linux
	fi
else
	echo "Looks kind of like a Version 7 system, but we'll see..."
	echo exit 0 >v7
fi
case "$eunicefix" in
*unixtovms*)
	$cat <<'EOI'
There is, however, a strange, musty smell in the air that reminds me of
something...hmm...yes...I've got it...there's a VMS nearby, or I'm a Blit.
EOI
	echo exit 0 >eunice
	d_eunice="$define"
: it so happens the Eunice I know will not run shell scripts in Unix format
	;;
*)
	echo " "
	echo "Congratulations.  You aren't running Eunice."
	d_eunice="$undef"
	;;
esac
if test -d c:/.; then
	case "X${MACHTYPE:-nonesuchmach}" in
	*cygwin) echo " "; echo "Hah!... you're running under Cygwin!";;
	*msys) echo " "; echo "Hah!... you're running under MinGW!";;
	esac
	case "X${MACHTYPE:-nonesuchmach}" in
	*cygwin|*msys)
		echo exit 0 >windows
		d_windows="$define"
		;;
	esac
fi
case "$p_" in
:) ;;
*)
	$cat <<'EOI'
I have the feeling something is not exactly right, however...don't tell me...
EOI
	if test -n "$DJGPP"; then
		echo exit 0 >dos
		d_dos="$define"
	else
		$cat <<'EOI'
lemme think...does HAL ring a bell?...no, of course, you're only running OS/2!
EOI
		echo exit 0 >os2
		d_os2="$define"
	fi
	;;
esac
if test -f /xenix; then
	echo "Actually, this looks more like a XENIX system..."
	echo exit 0 >xenix
	d_xenix="$define"
else
	echo " "
	echo "It's not Xenix..."
	d_xenix="$undef"
fi
chmod +x xenix
$eunicefix xenix
if test -f /venix; then
	echo "Actually, this looks more like a VENIX system..."
	echo exit 0 >venix
else
	echo " "
	if ./xenix; then
		: null
	else
		echo "Nor is it Venix..."
	fi
fi
chmod +x bsd usg v7 osf1 eunice xenix venix dos os2 gnu linux windows
$eunicefix bsd usg v7 osf1 eunice xenix venix dos os2 gnu linux windows
$rm -f foo

: What should the include directory be ?
echo " "
$echo $n "Hmm...  $c"
incpath=''
mips_type=''
if $test -f /bin/mips && /bin/mips; then
	echo "Looks like a MIPS system..."
	$cat >usr.c <<'EOCP'
#ifdef SYSTYPE_BSD43
/bsd43
#endif
EOCP
	if cc -E usr.c > usr.out && $contains / usr.out >/dev/null 2>&1; then
		dflt='/bsd43/usr/include'
		incpath='/bsd43'
		mips_type='BSD 4.3'
	else
		mips_type='System V'
	fi
	$rm -f usr.c usr.out
	echo "and you're compiling with the $mips_type compiler and libraries."
	echo "exit 0" >mips
else
	echo "Doesn't look like a MIPS system."
	echo "exit 1" >mips
fi
chmod +x mips
$eunicefix mips

: What should the include directory be ?
echo " "
dflt='/usr/include'
case "$usrinc" in
'') dflt="$incpath/usr/include";;
*) dflt="$usrinc";;
esac
fn=d/
rp='Where are the include files you want to use?'
. ./getfile
usrinc="$ans"

: see if we have to deal with yellow pages, now NIS.
if $test -d /usr/etc/yp || $test -d /etc/yp || $test -d /usr/lib/yp; then
	if $test -f /usr/etc/nibindd; then
		echo " "
		echo "I'm fairly confident you're on a NeXT."
		echo " "
		rp='Do you get the hosts file via NetInfo?'
		dflt=y
		case "$hostcat" in
		nidump*) ;;
		'') ;;
		*) dflt=n;;
		esac
		. ./myread
		case "$ans" in
		y*) hostcat='nidump hosts .';;
		*)	case "$hostcat" in
			nidump*) hostcat='';;
			esac
			;;
		esac
	fi
	case "$hostcat" in
	nidump*) ;;
	*)
		case "$hostcat" in
		*ypcat*) dflt=y;;
		'') if $contains '^\+' /etc/passwd >/dev/null 2>&1; then
				dflt=y
			else
				dflt=n
			fi;;
		*) dflt=n;;
		esac
		echo " "
		rp='Are you getting the hosts file via yellow pages?'
		. ./myread
		case "$ans" in
		y*) hostcat='ypcat hosts';;
		*) hostcat='cat /etc/hosts';;
		esac
		;;
	esac
fi
case "$hostcat" in
'') hostcat=':'
	$test -f /etc/hosts && hostcat='cat /etc/hosts';;
esac
case "$groupcat" in
'')	groupcat=':'
	$test -f /etc/group && groupcat='cat /etc/group';;
esac
case "$passcat" in
'') passcat=':'
	$test -f /etc/passwd && passcat='cat /etc/passwd';;
esac

: now get the host name
echo " "
echo "Figuring out host name..." >&4
case "$myhostname" in
'') cont=true
	echo 'Maybe "hostname" will work...'
	if tans=`sh -c hostname 2>&1` ; then
		myhostname=$tans
		phostname=hostname
		cont=''
	fi
	;;
*) cont='';;
esac
if $test "$cont"; then
	if ./xenix; then
		echo 'Oh, dear.  Maybe "/etc/systemid" is the key...'
		if tans=`cat /etc/systemid 2>&1` ; then
			myhostname=$tans
			phostname='cat /etc/systemid'
			echo "Whadyaknow.  Xenix always was a bit strange..."
			cont=''
		fi
	elif $test -r /etc/systemid; then
		echo "(What is a non-Xenix system doing with /etc/systemid?)"
	fi
fi
if $test "$cont"; then
	echo 'No, maybe "uuname -l" will work...'
	if tans=`sh -c 'uuname -l' 2>&1` ; then
		myhostname=$tans
		phostname='uuname -l'
	else
		echo 'Strange.  Maybe "uname -n" will work...'
		if tans=`sh -c 'uname -n' 2>&1` ; then
			myhostname=$tans
			phostname='uname -n'
		else
			echo 'Oh well, maybe I can mine it out of whoami.h...'
			if tans=`sh -c $contains' sysname $usrinc/whoami.h' 2>&1` ; then
				myhostname=`echo "$tans" | $sed 's/^.*"\(.*\)"/\1/'`
				phostname="sed -n -e '"'/sysname/s/^.*\"\\(.*\\)\"/\1/{'"' -e p -e q -e '}' <$usrinc/whoami.h"
			else
				case "$myhostname" in
				'') echo "Does this machine have an identity crisis or something?"
					phostname='';;
				*)
					echo "Well, you said $myhostname before..."
					phostname='echo $myhostname';;
				esac
			fi
		fi
	fi
fi
case "$myhostname" in
'') myhostname=noname ;;
esac
: you do not want to know about this
set $myhostname
myhostname=$1

: verify guess
if $test "$myhostname" ; then
	dflt=y
	rp='Your host name appears to be "'$myhostname'".'" Right?"
	. ./myread
	case "$ans" in
	y*) ;;
	*) myhostname='';;
	esac
fi

: bad guess or no guess
while $test "X$myhostname" = X ; do
	dflt=''
	rp="Please type the (one word) name of your host:"
	. ./myread
	myhostname="$ans"
done

: translate upper to lower if necessary
case "$myhostname" in
*[A-Z]*)
	echo "(Normalizing case in your host name)"
	myhostname=`echo $myhostname | ./tr '[A-Z]' '[a-z]'`
	;;
esac

case "$myhostname" in
*.*)
	dflt=`expr "X$myhostname" : "X[^.]*\(\..*\)"`
	myhostname=`expr "X$myhostname" : "X\([^.]*\)\."`
	echo "(Trimming domain name from host name--host name is now $myhostname)"
	;;
*) case "$mydomain" in
	'')
		{
			test "X$hostcat" = "Xypcat hosts" &&
			ypmatch "$myhostname" hosts 2>/dev/null |\
				$sed -e 's/[	 ]*#.*//; s/$/ /' > hosts && \
			$test -s hosts
		} || {
		     	$hostcat | $sed -n -e "s/[	 ]*#.*//; s/\$/ /
					/[	 ]$myhostname[	. ]/p" > hosts
		}
		tmp_re="[	. ]"
		$test x`$awk "/[0-9].*[	 ]$myhostname$tmp_re/ { sum++ }
			     END { print sum }" hosts` = x1 || tmp_re="[	 ]"
		dflt=.`$awk \
		"/[0-9].*[	 ]$myhostname$tmp_re/ {for(i=2; i<=NF;i++) print \\\$i}" \
			hosts | $sort | $uniq | \
			$sed -n -e "s/$myhostname\.\([-a-zA-Z0-9_.]\)/\1/p"`
		case `$echo X$dflt` in
		X*\ *)	echo "(Several hosts in /etc/hosts matched hostname)"
			dflt=.
			;;
		X.)
			if $test -f /etc/hosts; then
				echo "(You do not have fully-qualified names in /etc/hosts)"
			else
				echo "(I cannot locate a hosts database anywhere)"
			fi
			;;
		esac
		case "$dflt" in
		.)
			tans=`./loc resolv.conf X /etc /usr/etc`
			if $test -f "$tans"; then
				echo "(Attempting domain name extraction from $tans)"
				dflt=.`$sed -n -e 's/	/ /g' \
				  -e 's/^search  *\([^ ]*\).*/\1/p' $tans \
				  | ./tr '[A-Z]' '[a-z]' 2>/dev/null`
				case "$dflt" in
				.) dflt=.`$sed -n -e 's/	/ /g' \
				     -e 's/^domain  *\([^ ]*\).*/\1/p' $tans \
				     | ./tr '[A-Z]' '[a-z]' 2>/dev/null`
  					;;
				esac
			fi
			;;
		esac
		case "$dflt" in
		.) echo "(No help from resolv.conf either -- attempting clever guess)"
			dflt=.`sh -c domainname 2>/dev/null`
			case "$dflt" in
			'') dflt='.';;
			.nis.*|.yp.*|.main.*) dflt=`echo $dflt | $sed -e 's/^\.[^.]*//'`;;
			esac
			;;
		esac
		case "$dflt$osname" in
		.os390)
			file="//'SYS1.TCPPARMS(TCPDATA)'"
			echo "(Attempting domain name extraction from $file)"
			dflt=.`awk '/^DOMAINORIGIN/ {print $2}' "$file" 2>/dev/null`
			;;
			esac
		case "$dflt" in
		.) echo "(Lost all hope -- silly guess then)"
			dflt='.nonet'
			;;
		esac
		$rm -f hosts
		;;
	*) dflt="$mydomain";;
	esac;;
esac
echo " "
rp="What is your domain name?"
. ./myread
tans="$ans"
case "$ans" in
'') ;;
.*) ;;
*) tans=".$tans";;
esac
mydomain="$tans"

: translate upper to lower if necessary
case "$mydomain" in
*[A-Z]*)
	echo "(Normalizing case in your domain name)"
	mydomain=`echo $mydomain | ./tr '[A-Z]' '[a-z]'`
	;;
esac

: a little sanity check here
case "$phostname" in
'') ;;
*)
	case `$phostname | ./tr '[A-Z]' '[a-z]'` in
	$myhostname$mydomain|$myhostname) ;;
	*)
		case "$phostname" in
		sed*)
			echo "(That doesn't agree with your whoami.h file, by the way.)"
			;;
		*)
			echo "(That doesn't agree with your $phostname command, by the way.)"
			;;
		esac
	;;
	esac
	;;
esac

: determine the e-mail address of the user who is running us
$cat <<EOM

I need to get your e-mail address in Internet format if possible, i.e.
something like user@host.domain. Please answer accurately since I have
no easy means to double check it. The default value provided below
is most probably close to reality but may not be valid from outside
your organization...

EOM
cont=x
while test "$cont"; do
	case "$MAILDOMAIN" in
	'')
		if $test -s /etc/mailname; then
			maildomain=`$cat /etc/mailname`
		else
			maildomain="$myhostname$mydomain"
		fi
		;;
	*)  maildomain="$MAILDOMAIN";;
	esac
	case "$cf_email" in
	'') dflt="$cf_by@$maildomain";;
	*)  dflt="$cf_email";;
	esac
	rp='What is your e-mail address?'
	. ./myread
	cf_email="$ans"
	case "$cf_email" in
	*@*.*) cont='' ;;
	*)
		rp='Address does not look like an Internet one.  Use it anyway?'
		case "$fastread" in
		yes) dflt=y ;;
		*) dflt=n ;;
		esac
		. ./myread
		case "$ans" in
		y*) cont='' ;;
		*) echo " " ;;
		esac
		;;
	esac
done

: how do we get traditional cpp semantics?
echo " "
echo "Checking to see how to get traditional cpp semantics..." >&4
$cat >foo.c <<'EOF'
#define A(x) x
#define B(y) y
A(a)B(b)
EOF
if $cpp foo.c >foo.cpp; $contains ab foo.cpp >/dev/null 2>&1; then
	echo "Plain '$cpp' works just fine."
	cpp_trad="$cpp"
elif $cpp -traditional foo.c >foo.cpp; \
	$contains ab foo.cpp >/dev/null 2>&1; then
	echo "We'll use '$cpp -traditional' to get proper semantics."
	cpp_trad="$cpp -traditional"
else
	echo "I don't know how to get traditional semantics with '$cpp'." >&4
	cpp_trad="$cpp"
fi
$rm -f foo.c foo.cpp

: Check whether they have gcc in any guise.  
echo " "
echo "Checking for GNU cc in disguise and/or its version number..." >&4
$cat >try.c <<EOM
int main(void) {
#ifdef __GNUC__
gcc_version_major __GNUC__
#ifdef __GNUC_MINOR__
gcc_version_minor __GNUC__
#endif
#ifdef __GNUC_PATCHLEVEL__
gcc_version_patchlevel __GNUC_PATCHLEVEL__
#endif
#endif
}
EOM
if $cc -E try.c > try 2>&1
then
	gccversion=`$grep gcc_version_major try |
		sed 's/^.*gcc_version_major[\t ]*//'`
	case "$gccversion" in
	'') echo "You are not using GNU cc." ;;
	*)  echo "You are using GNU cc $gccversion."
	    ccname=gcc	
	    ;;
	esac
else
	gccversion=''
fi
$rm -f try try.*
case "$gccversion" in
1*) cpp=`./loc gcc-cpp $cpp $pth` ;;
esac
case "$gccversion" in
'') gccosandvers='' ;;
*) gccshortvers=`echo "$gccversion"|sed 's/ .*//'`
   gccosandvers=`$cc -v 2>&1 | \
	$grep '/specs$'|sed "s!.*/[^-/]*-[^-/]*-\([^-/]*\)/$gccshortvers/specs!\1!"`
   gccshortvers=''
   case "$gccosandvers" in
   $osname) gccosandvers='' ;; # linux gccs seem to have no linux osvers, grr
   $osname$osvers) ;; # looking good
   $osname*) cat <<EOM >&4

*** WHOA THERE!!! ***

    Your gcc has not been compiled for the exact release of
    your operating system ($gccosandvers versus $osname$osvers).

    In general it is a good idea to keep gcc synchronized with
    the operating system because otherwise serious problems
    may ensue when trying to compile software, like Perl.

    I'm trying to be optimistic here, though, and will continue.
    If later during the configuration and build icky compilation
    problems appear (headerfile conflicts being the most common
    manifestation), I suggest reinstalling the gcc to match
    your operating system release.

EOM
      ;;
   *) gccosandvers='' ;; # failed to parse, better be silent
   esac
   ;;
esac
case "$ccname" in
'') ccname="$cc" ;;
esac

: gcc 3.1 complains about adding -Idirectories that it already knows about,
: so we will take those off from locincpth.
case "$gccversion" in
3*)
    echo "main(){}">try.c
    for incdir in `$cc -v -c try.c 2>&1 | \
       sed '1,/^#include <\.\.\.>/d;/^End of search list/,$d;s/^ //'` ; do
       locincpth=`echo $locincpth | sed s!$incdir!!`
    done
    $rm -f try try.*
esac

: see how we invoke the C preprocessor
echo " "
echo "Now, how can we feed standard input to your C preprocessor..." >&4
cat <<'EOT' >testcpp.c
#define ABC abc
#define XYZ xyz
ABC.XYZ
EOT
cd ..
if $test ! -f cppstdin; then
	echo "$startsh" >cppstdin
if $test "X$osname" = "Xaix" -a "X$gccversion" = X; then
	echo 'cat >.$$.c; rm -f .$$.u; '"$cc"' ${1+"$@"} -M -c .$$.c 2>/dev/null; \
	test -s .$$.u && \
	awk '"'"'$2 ~ /\.h$/ { print "# 0 \""$2"\"" }'"'"' .$$.u; \
	rm -f .$$.o .$$.u; '"$cc"' -E ${1+"$@"} .$$.c; rm .$$.c' >> cppstdin
else
	echo 'cat >.$$.c; '"$cc"' -E ${1+"$@"} .$$.c; rm .$$.c' >>cppstdin
fi; else
	echo "Keeping your $hint cppstdin wrapper."
fi
chmod 755 cppstdin
$eunicefix cppstdin
wrapper=`pwd`/cppstdin
ok='false'
cd UU

if $test "X$cppstdin" != "X" && \
	$cppstdin $cppminus <testcpp.c >testcpp.out 2>&1 && \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1
then
	echo "You used to use $cppstdin $cppminus so we'll use that again."
	case "$cpprun" in
	'') echo "But let's see if we can live without a wrapper..." ;;
	*)
		if $cpprun $cpplast <testcpp.c >testcpp.out 2>&1 && \
			$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1
		then
			echo "(And we'll use $cpprun $cpplast to preprocess directly.)"
			ok='true'
		else
			echo "(However, $cpprun $cpplast does not work, let's see...)"
		fi
		;;
	esac
else
	case "$cppstdin" in
	'') ;;
	*)
		echo "Good old $cppstdin $cppminus does not seem to be of any help..."
		;;
	esac
fi

if $ok; then
	: nothing
elif echo 'Maybe "'"$cc"' -E" will work...'; \
	$cc -E <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Yup, it does."
	x_cpp="$cc -E"
	x_minus='';
elif echo 'Nope...maybe "'"$cc"' -E -" will work...'; \
	$cc -E - <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Yup, it does."
	x_cpp="$cc -E"
	x_minus='-';
elif echo 'Nope...maybe "'"$cc"' -P" will work...'; \
	$cc -P <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Yipee, that works!"
	x_cpp="$cc -P"
	x_minus='';
elif echo 'Nope...maybe "'"$cc"' -P -" will work...'; \
	$cc -P - <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "At long last!"
	x_cpp="$cc -P"
	x_minus='-';
elif echo 'No such luck, maybe "'$cpp'" will work...'; \
	$cpp <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "It works!"
	x_cpp="$cpp"
	x_minus='';
elif echo 'Nixed again...maybe "'$cpp' -" will work...'; \
	$cpp - <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Hooray, it works!  I was beginning to wonder."
	x_cpp="$cpp"
	x_minus='-';
elif echo 'Uh-uh.  Time to get fancy.  Trying a wrapper...'; \
	$wrapper <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	x_cpp="$wrapper"
	x_minus=''
	echo "Eureka!"
else
	dflt=''
	rp="No dice.  I can't find a C preprocessor.  Name one:"
	. ./myread
	x_cpp="$ans"
	x_minus=''
	$x_cpp <testcpp.c >testcpp.out 2>&1
	if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
		echo "OK, that will do." >&4
	else
echo "Sorry, I can't get that to work.  Go find one and rerun Configure." >&4
		exit 1
	fi
fi

case "$ok" in
false)
	cppstdin="$x_cpp"
	cppminus="$x_minus"
	cpprun="$x_cpp"
	cpplast="$x_minus"
	set X $x_cpp
	shift
	case "$1" in
	"$cpp")
		echo "Perhaps can we force $cc -E using a wrapper..."
		if $wrapper <testcpp.c >testcpp.out 2>&1; \
			$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1
		then
			echo "Yup, we can."
			cppstdin="$wrapper"
			cppminus='';
		else
			echo "Nope, we'll have to live without it..."
		fi
		;;
	esac
	case "$cpprun" in
	"$wrapper")
		cpprun=''
		cpplast=''
		;;
	esac
	;;
esac

case "$cppstdin" in
"$wrapper"|'cppstdin') ;;
*) $rm -f $wrapper;;
esac
$rm -f testcpp.c testcpp.out

: Set private lib path
case "$plibpth" in
'') if ./mips; then
		plibpth="$incpath/usr/lib /usr/local/lib /usr/ccs/lib"
	fi;;
esac
case "$libpth" in
' ') dlist='';;
'') dlist="$loclibpth $plibpth $glibpth";;
*) dlist="$libpth";;
esac

: Now check and see which directories actually exist, avoiding duplicates
libpth=''
for xxx in $dlist
do
    if $test -d $xxx; then
		case " $libpth " in
		*" $xxx "*) ;;
		*) libpth="$libpth $xxx";;
		esac
    fi
done
$cat <<'EOM'

Some systems have incompatible or broken versions of libraries.  Among
the directories listed in the question below, please remove any you
know not to be holding relevant libraries, and add any that are needed.
Say "none" for none.

EOM
case "$libpth" in
'') dflt='none';;
*)
	set X $libpth
	shift
	dflt=${1+"$@"}
	;;
esac
rp="Directories to use for library searches?"
. ./myread
case "$ans" in
none) libpth=' ';;
*) libpth="$ans";;
esac

: determine optimize, if desired, or use for debug flag also
case "$optimize" in
' '|$undef) dflt='none';;
'')
	case "$gccversion" in
	'') dflt='-O';;
	*) dflt='-O2 -g';;
	esac
	;;
*) dflt="$optimize";;
esac
case "$gccversion" in
'') $cat <<EOH

Some C compilers have problems with their optimizers.  By default, $package
compiles with the -O flag to use the optimizer.  Alternately, you might want
to use the symbolic debugger, which uses the -g flag (on traditional Unix
systems).  Either flag can be specified here.  To use neither flag, specify
the word "none".

EOH
	;;
*) $cat <<EOH

With the GNU C compiler, it is possible to supply both -O2 and -g flags, to
be able to reasonably optimize, whilst retaining the ability to use a
symbolic debugger.  Either flag can be specified here.  To use neither flag,
specify the word "none".

EOH
	;;
esac
rp="What optimizer/debugger flag should be used?"
. ./myread
optimize="$ans"
case "$optimize" in
'none') optimize=" ";;
esac


dflt=''
: We will not override a previous value, but we might want to
: augment a hint file
case "$hint" in
default|recommended)
	case "$gccversion" in
	1*) dflt='-fpcc-struct-return' ;;
	esac
	case "$gccversion" in
	2*) if test -d /etc/conf/kconfig.d &&
			$contains _POSIX_VERSION $usrinc/sys/unistd.h >/dev/null 2>&1
		then
			dflt="$dflt -posix"
		fi
		;;
	esac
	case "$gccversion" in
	1*|2*) dflt="$dflt -Wall";;
	*) dflt="$dflt -W -Wall -Wformat=2 -Wshadow";;
	esac
	;;
esac

case "$mips_type" in
*BSD*|'') inclwanted="$locincpth $usrinc";;
*) inclwanted="$locincpth $inclwanted $usrinc/bsd";;
esac
for thisincl in $inclwanted; do
	if $test -d $thisincl; then
		if $test x$thisincl != x$usrinc; then
			case "$dflt" in
			*$thisincl*);;
			*) dflt="$dflt -I$thisincl";;
			esac
		fi
	fi
done

inctest='if $contains $2 $usrinc/$1 >/dev/null 2>&1; then
	xxx=true;
elif $contains $2 $usrinc/sys/$1 >/dev/null 2>&1; then
	xxx=true;
else
	xxx=false;
fi;
if $xxx; then
	case "$dflt" in
	*$2*);;
	*) dflt="$dflt -D$2";;
	esac;
fi'

if ./osf1; then
	set signal.h __LANGUAGE_C__; eval $inctest
else
	set signal.h LANGUAGE_C; eval $inctest
fi

case "$hint" in
default|recommended) dflt="$dflt $ccflags" ;;
*) dflt="$ccflags";;
esac

case "$dflt" in
''|' ') dflt=none;;
esac
$cat <<EOH

Your C compiler may want other flags.  For this question you should include
-I/whatever and -DWHATEVER flags and any other flags used by the C compiler,
but you should NOT include libraries or ld flags like -lwhatever.

To use no flags, specify the word "none".

EOH
set X $dflt
shift
dflt=${1+"$@"}
rp="Any additional cc flags?"
. ./myread
case "$ans" in
none) ccflags='';;
*) ccflags="$ans";;
esac

: the following weeds options from ccflags that are of no interest to cpp
cppflags="$ccflags"
case "$gccversion" in
1*) cppflags="$cppflags -D__GNUC__"
esac
case "$mips_type" in
'');;
*BSD*) cppflags="$cppflags -DSYSTYPE_BSD43";;
esac
case "$cppflags" in
'');;
*)
	echo " "
	echo "Let me guess what the preprocessor flags are..." >&4
	set X $cppflags
	shift
	cppflags=''
	$cat >cpp.c <<'EOM'
#define BLURFL foo

BLURFL xx LFRULB
EOM
	previous=''
	for flag in $*
	do
		case "$flag" in
		-*) ftry="$flag";;
		*) ftry="$previous $flag";;
		esac
		if $cppstdin -DLFRULB=bar $ftry $cppminus <cpp.c \
			>cpp1.out 2>/dev/null && \
			$cpprun -DLFRULB=bar $ftry $cpplast <cpp.c \
			>cpp2.out 2>/dev/null && \
			$contains 'foo.*xx.*bar' cpp1.out >/dev/null 2>&1 && \
			$contains 'foo.*xx.*bar' cpp2.out >/dev/null 2>&1
		then
			cppflags="$cppflags $ftry"
			previous=''
		else
			previous="$flag"
		fi
	done
	set X $cppflags
	shift
	cppflags=${1+"$@"}
	case "$cppflags" in
	*-*)  echo "They appear to be: $cppflags";;
	esac
	$rm -f cpp.c cpp?.out
	;;
esac

: flags used in final linking phase
case "$ldflags" in
'') if ./venix; then
		dflt='-i -z'
	else
		dflt=''
	fi
	case "$ccflags" in
	*-posix*) dflt="$dflt -posix" ;;
	esac
	;;
*) dflt="$ldflags";;
esac

: Try to guess additional flags to pick up local libraries.
for thislibdir in $libpth; do
	case " $loclibpth " in
	*" $thislibdir "*)
		case "$dflt " in 
		*"-L$thislibdir "*) ;;
		*)  dflt="$dflt -L$thislibdir" ;;
		esac
		;;
	esac
done

case "$dflt" in
'') dflt='none' ;;
*) set X $dflt; shift; dflt="$@";;
esac

$cat <<EOH

Your C linker may need flags.  For this question you should
include -L/whatever and any other flags used by the C linker, but you
should NOT include libraries like -lwhatever.

Make sure you include the appropriate -L/path flags if your C linker
does not normally search all of the directories you specified above,
namely
	$libpth
To use no flags, specify the word "none".

EOH

rp="Any additional ld flags (NOT including libraries)?"
. ./myread
case "$ans" in
none) ldflags='';;
*) ldflags="$ans";;
esac
rmlist="$rmlist pdp11"

: coherency check
echo " "
echo "Checking your choice of C compiler and flags for coherency..." >&4
set X $cc $optimize $pthread $ccflags $ldflags -o try try.c
shift
$cat >try.msg <<EOM
I've tried to compile and run a simple program with:

	$*
	./try

and I got the following output:

EOM
$cat > try.c <<'EOF'
int main() { return 0; }
EOF
dflt=y
if sh -c "$cc $optimize $ccflags $ldflags -o try try.c" >>try.msg 2>&1; then
	if sh -c './try' >>try.msg 2>&1; then
		dflt=n
	else
		echo "The program compiled OK, but exited with status $?." >>try.msg
		rp="You have a problem.  Shall I abort Configure"
		dflt=y
	fi
else
	echo "I can't compile the test program." >>try.msg
	rp="You have a BIG problem.  Shall I abort Configure"
	dflt=y
fi
case "$dflt" in
y)
	$cat try.msg >&4
	case "$knowitall" in
	'')
		echo "(The supplied flags might be incorrect with this C compiler.)"
		;;
	*) dflt=n;;
	esac
	echo " "
	. ./myread
	case "$ans" in
	n*|N*) ;;
	*)	echo "Ok.  Stopping Configure." >&4
		exit 1
		;;
	esac
	;;
n) echo "OK, that should do.";;
esac
$rm -f try try.* core

: determine default editor
echo " "
case "$defeditor" in
'')
	case "$vi" in
	*/*) dflt="$vi";;
	*) dflt=/usr/ucb/vi;;
	esac
	;;
*)  dflt="$defeditor"
	;;
esac
fn=f/
rp="What is the default editor on your system?"
. ./getfile
defeditor="$ans"

: locate a BSD compatible install program
echo " "
echo "Looking for a BSD-compatible install program..." >&4
creatdir=''
case "$install" in
'')
	tryit=''
	for dir in $pth; do
		for file in ginstall installbsd scoinst install; do
			if $test -f $dir/$file; then
				tryit="$tryit $dir/$file"
			fi
		done
	done
	$cat >try.c <<EOC
int main()
{
	printf("OK\n");
	exit(0);
}
EOC
	if $cc -o try try.c >/dev/null 2>&1; then
		cp try try.ns
		strip try >/dev/null 2>&1
	else
		echo "(I can't seem to compile a trivial C program -- bypassing.)"
		echo "try" >try
		cp try try.ns
	fi
	$cat >tryinst <<EOS
$startsh
$rm -rf foo d
\$1 -d foo/bar
$mkdir d
\$1 -c -m 764 try.ns d
\$1 -c -s -m 642 try.ns d/try
EOS
	chmod +x tryinst
	$eunicefix tryinst
	dflt=''
	either=''
	for prog in $tryit; do
		$echo $n "Checking $prog... $c"
		./tryinst $prog >/dev/null 2>&1
		if $test -d foo/bar; then
			creatdir="$prog -d"
		fi
		(ls -l d/try >try.ls; ls -l d/try.ns >tryno.ls) 2>/dev/null
		try_wc=`($wc -c try | $awk '{ print $1}') 2>/dev/null`
		tryns_wc=`($wc -c try.ns | $awk '{ print $1}') 2>/dev/null`
		d_try_wc=`($wc -c d/try | $awk '{ print $1}') 2>/dev/null`
		d_tryns_wc=`($wc -c d/try.ns | $awk '{ print $1}') 2>/dev/null`
		if ($test "X$try_wc" = "X$d_try_wc" && \
			$test "X$tryns_wc" = "X$d_tryns_wc" && \
			$contains 'rwxrw-r--' tryno.ls && \
			$contains 'rw-r---w-' try.ls) >/dev/null 2>&1
		then
			dflt="$prog"
			echo "ok, that will do."
			break
		fi
		echo "not good$either."
		either=' either'
		$rm -f try*.ls
	done
	$rm -rf foo d tryinst try try*.ls try.*
	case "$dflt" in
	'')
		echo "Hopefully, $package comes with its own install script!"
		dflt='./install'
		;;
	esac
	;;
*) dflt="$install";;
esac
$cat <<EOM

I will be requiring a BSD-compatible install program (one that allows
options like -s to strip executables or -m to specify a file mode) to
install $package.

If the question below contains a fully qualified default path, then it
is probably ok. If it is an unqualified name such as 'install', then it
means I was unable to find out a good install program I could use. If
you know of one, please tell me about it. If the default is './install',
then I shall be using the install script supplied with $package.

EOM
fn='/fe~(install,./install)'
rp='Which install program shall I use?'
. ./getfile
install="$ans"

: how can we create nested directories?
echo " "
echo "Ok, let's see how we can create nested directories..." >&4
case "$installdir" in
'')
	$mkdir -p foo/bar >/dev/null 2>&1
	if $test -d foo/bar; then
		echo "Great, we can build them using 'mkdir -p'."
		creatdir='mkdir -p'
	else
		case "$creatdir" in
		'')
			if eval "$install -d foo/bar"; $test -d foo/bar; then
				creatdir="install -d"
				echo "It looks like '$creatdir' will do it for us."
			fi
			;;
		*)
			eval "$creatdir foo/bar" >/dev/null 2>&1
			if $test -d foo/bar; then
				echo "Ah! We can use '$creatdir' to do just that."
			else
				creatdir=''
			fi
			;;
		esac
	fi
	$rm -rf foo
	case "$creatdir" in
	'')
		echo "Heck! Another ancient system lacking the comfort of modern ones!"
		echo "You can thank $package for bringing you its own install script!"
		installdir='./install -d'
		;;
	*) installdir="$creatdir";;
	esac
	;;
*) echo "As you already told me, '$installdir' should work.";;
esac

: determine the name of a reasonable mailer
case "$mailer" in
'')
	if $test -f "$sendmail"; then
		dflt="$sendmail"
	elif $test -f "$smail"; then
		dflt="$smail"
	elif $test -f "$rmail"; then
		dflt="$rmail"
	elif $test -f /bin/mail; then
		dflt=/bin/mail
	else
		dflt=$mail
	fi
	;;
*)  dflt="$mailer";;
esac
$cat <<EOM

I need the full pathname of the program used to deliver mail on your system.
A typical answer would be /usr/lib/sendmail or /bin/rmail, but you may choose
any other program, as long as it can be fed from standard input and will
honour any user-supplied headers.

EOM
fn=f
rp='Mail transport agent to be used?'
. ./getfile
mailer="$ans"

: find out how to find out full name
case "$d_berknames" in
"$define")
	dflt=y;;
"$undef")
	dflt=n;;
*)
	if ./bsd; then
		dflt=y
	elif ./xenix; then
		dflt=y
	else
		dflt=n
	fi
	;;
esac
$cat <<'EOM'

Does your /etc/passwd file keep full names in Berkeley/V7 format (name first
thing after ':' in GCOS field)?  In that case, a typical entry in the password
file looks like this:

    guest:**paswword**:10:100:Mister Guest User:/usr/users:/bin/sh
                              ^^^^^^^^^^^^^^^^^
EOM
rp="Berkeley/V7 format for full name in /etc/passwd?"
. ./myread
case "$ans" in
y*) d_passnames="$define"
	d_berknames="$define"
	d_usgnames="$undef"
	nametype=bsd
	;;
*)
	case "$d_usgnames" in
	"$define") dflt=y;;
	"$undef") dflt=n;;
	*)
		if ./usg; then
			dflt=y
		else
			dflt=n
		fi
		;;
	esac
$cat <<'EOM'

Does your passwd file keep full names in USG format (name sandwiched between a
'-' and a '(')?  In that case, a typical entry in the password file looks like
this:

    guest:**paswword**:10:100:000-Mister Guest User(000):/usr/users:/bin/sh
                                  ^^^^^^^^^^^^^^^^^
EOM
	rp="USG format for full name in /etc/passwd?"
	. ./myread
	case "$ans" in
	n*) echo "Full name will be taken from ~/.fullname"
		d_passnames="$undef"
		d_berknames="$undef"
		d_usgnames="$undef"
		nametype=other
		;;
	*)
		d_passnames="$define"
		d_berknames="$undef"
		d_usgnames="$define"
		nametype=usg
		;;
	esac;;
esac

: get organization name
longshots='/local/src /usr/src/new /usr/src/local /usr/local/src'
case "$orgname" in
'') if xxx=`./loc news/src/defs.h x $longshots`; then
		dflt=`$sed -n 's/^.*MYORG[ 	]*"\(.*\)".*$/\1/p' $xxx`
	else
		dflt=''
	fi
	;;
*)  dflt="$orgname";;
esac
$cat << 'EOH'
 
Please type the name of your organization as you want it to appear on the
Organization line of outgoing articles.  (It's nice if this also specifies
your location.  Your city name is probably sufficient if well known.)
For example:

    University of Southern North Dakota, Hoople

You may also put the name of a file, as long as it begins with a slash.
For example:

    /etc/organization

EOH
orgname=""
while test "X$orgname" = "X"; do
	rp='Organization:'
	. ./myread
	orgname="$ans"
done

: locate the preferred pager for this system
fn=f/
case "$pager" in
'')
	dflt=''
	case "$pg" in
	/*) dflt=$pg;;
	[a-zA-Z]:/*) dflt=$pg;;
	esac
	case "$more" in
	/*) dflt=$more;;
	[a-zA-Z]:/*) dflt=$more;;
	esac
	case "$less" in
	/*) dflt=$less;;
	[a-zA-Z]:/*) dflt=$less;;
	esac
	case "$dflt" in
	'') dflt=/usr/ucb/more;;
	esac
	;;
*)	dflt="$pager"
	fn="f/($pager)"
	;;
esac
echo " "
rp='What pager is used on your system?'
. ./getfile
pager="$ans"

: get the patchlevel / revision
echo " "
echo "Getting the current patchlevel / revision..." >&4
if $test -r $rsrc/patchlevel.h;then
	patchlevel=`awk \
		'/^#[ 	]*define[ 	][ 	]*PATCHLEVEL/ {print $3}' \
		< $rsrc/patchlevel.h`
else
	patchlevel=0
fi
if $test -r $rsrc/revision.h;then
	revision=`awk \
		'/^#[ 	]*define[ 	][ 	]*REVISION/ {print $3}' \
		< $rsrc/revision.h`
	case "$revision" in
	'"$Revision:')
		revision=`awk \
			'/^#[ 	]*define[ 	][ 	]*REVISION/ {print $4}' \
			< $rsrc/revision.h`
		;;
	esac
else
	revision=0
fi
case "$revision" in
0) echo "(You have $package $baserev PL$patchlevel.)" ;;
*)
	case "$patchlevel" in
	0) echo "(You have $package $baserev-$revision)";;
	*) echo "(You have $package $baserev-$revision PL$patchlevel)";;
	esac
	;;
esac

: determine perl absolute location
case "$perlpath" in
'')
	if test -f /usr/bin/perl; then
		dflt=/usr/bin/perl
	else
		case "$perl" in
		*/*) dflt="$perl";;
		*) dflt=/usr/bin/perl;;
		esac
	fi
	;;
*)  dflt="$perlpath"
	;;
esac
echo " "
fn=f~/
rp="Where is perl located on your system?"
. ./getfile
perlpath="$ans"

: figure out how to guarantee perl startup
case "$sharpbang" in
*!)
	$cat >xtry <<EOP
#!$perlpath
system("exit 0");
EOP
	chmod a+x xtry
	if ./xtry >/dev/null 2>&1; then
		$cat <<EOH

I can use the #! construct to start perl on your system. This will make
startup of perl scripts faster, but may cause problems if you want to share
those scripts and perl is not in a standard place (/usr/bin/perl) on all your
platforms. The alternative is to force a shell by starting the script with a
single ':' character.

EOH
		pdflt=y
	else
		$cat <<EOH

I could use the #! construct to start perl on your system, but using
    #!$perlpath
would be too long for your kernel to grok. Indeed, most systems do
limit the size of the leading #! string to 32 characters.

EOH
		pdflt=n
	fi
	$rm -f xtry
	case "$startperl" in
	*!*) dflt=y;;
	'') case "$d_portable" in
		"$define") dflt=n;;
		*) dflt=$pdflt;;
		esac;;
	*) dflt=n;;
	esac
	rp='Shall I use #! to start up perl?'
	. ./myread
	case "$ans" in
	y*|Y*) startperl="#!$perlpath";;
	*) startperl=": # use perl";;
	esac;;
*) startperl=": # use perl";;
esac

: end of configuration questions
echo " "
echo "End of configuration questions."

: back to where it started
if test -d ../UU; then
	cd ..
fi

: configuration may be unconditionally patched via a 'config.arch' file
if $test -f config.arch; then
	echo "I see a config.arch file, loading it." >&4
	. ./config.arch
fi

: configuration may be patched via a 'config.over' file
if $test -f config.over; then
	echo " "
	dflt=y
	rp='I see a config.over file.  Do you wish to load it?'
	. UU/myread
	case "$ans" in
	n*) echo "OK, I'll ignore it.";;
	*)	. ./config.over
		echo "Configuration override changes have been loaded."
		;;
	esac
fi

: in case they want portability, strip down executable paths
case "$d_portable" in
"$define")
	echo " "
	echo "Stripping down executable paths..." >&4
	xsed=$sed
	for file in $loclist $trylist; do
		eval sfile="\$$file"
		sfile=`echo $sfile | $xsed -e 's,.*/\(.*\),\1,'`
		eval $file="$sfile"
	done
	;;
esac

: create config.sh file
echo " "
echo "Creating config.sh..." >&4
$spitshell <<EOT >config.sh
$startsh
#
# This file was produced by running the Configure script. It holds all the
# definitions figured out by Configure. Should you modify one of these values,
# do not forget to propagate your changes by running "Configure -der". You may
# instead choose to run each of the .SH files by yourself, or "Configure -S".
#

# Package name      : $package
# Source directory  : $src
# Configuration time: $cf_time
# Configured by     : $cf_by
# Target system     : $myuname

EOT
$test -f UU/cmdline.opt && $cat UU/cmdline.opt >> config.sh
$spitshell <<EOT >>config.sh

Author='$Author'
Date='$Date'
Header='$Header'
Id='$Id'
Locker='$Locker'
Log='$Log'
RCSfile='$RCSfile'
Revision='$Revision'
Source='$Source'
State='$State'
_a='$_a'
_exe='$_exe'
_o='$_o'
afs='$afs'
afsroot='$afsroot'
ar='$ar'
archobjs='$archobjs'
awk='$awk'
baserev='$baserev'
bash='$bash'
bison='$bison'
byacc='$byacc'
c='$c'
cat='$cat'
ccflags='$ccflags'
ccname='$ccname'
ccversion='$ccversion'
cf_by='$cf_by'
cf_email='$cf_email'
cf_time='$cf_time'
chgrp='$chgrp'
chmod='$chmod'
chown='$chown'
comm='$comm'
compress='$compress'
contains='$contains'
cp='$cp'
cpio='$cpio'
cpp='$cpp'
cpp_trad='$cpp_trad'
cppflags='$cppflags'
cpplast='$cpplast'
cppminus='$cppminus'
cpprun='$cpprun'
cppstdin='$cppstdin'
csh='$csh'
d_berknames='$d_berknames'
d_bsd='$d_bsd'
d_dos='$d_dos'
d_eunice='$d_eunice'
d_linux='$d_linux'
d_os2='$d_os2'
d_passnames='$d_passnames'
d_portable='$d_portable'
d_usgnames='$d_usgnames'
d_windows='$d_windows'
d_xenix='$d_xenix'
date='$date'
defeditor='$defeditor'
echo='$echo'
egrep='$egrep'
emacs='$emacs'
eunicefix='$eunicefix'
expr='$expr'
find='$find'
firstmakefile='$firstmakefile'
flex='$flex'
from='$from'
gcc='$gcc'
gccosandvers='$gccosandvers'
gccversion='$gccversion'
glibpth='$glibpth'
gmake='$gmake'
gmsgfmt='$gmsgfmt'
grep='$grep'
groupcat='$groupcat'
gzip='$gzip'
hint='$hint'
hostcat='$hostcat'
incpath='$incpath'
inews='$inews'
install='$install'
installdir='$installdir'
installmansrc='$installmansrc'
installprivlib='$installprivlib'
installscript='$installscript'
issymlink='$issymlink'
ksh='$ksh'
ldflags='$ldflags'
less='$less'
libpth='$libpth'
line='$line'
lint='$lint'
lkflags='$lkflags'
ln='$ln'
lns='$lns'
locincpth='$locincpth'
loclibpth='$loclibpth'
lp='$lp'
lpr='$lpr'
ls='$ls'
mail='$mail'
mailer='$mailer'
mailx='$mailx'
make='$make'
make_set_make='$make_set_make'
manext='$manext'
mansrc='$mansrc'
mansrcexp='$mansrcexp'
mips_type='$mips_type'
mkdir='$mkdir'
more='$more'
msgfmt='$msgfmt'
msgmerge='$msgmerge'
mv='$mv'
mydomain='$mydomain'
myhostname='$myhostname'
myuname='$myuname'
n='$n'
nametype='$nametype'
nawk='$nawk'
nm='$nm'
nroff='$nroff'
optimize='$optimize'
orgname='$orgname'
osname='$osname'
osvers='$osvers'
package='$package'
pager='$pager'
passcat='$passcat'
patchlevel='$patchlevel'
perl='$perl'
perlpath='$perlpath'
pg='$pg'
phostname='$phostname'
pkgsrc='$pkgsrc'
plibpth='$plibpth'
pmake='$pmake'
pr='$pr'
prefix='$prefix'
prefixexp='$prefixexp'
privlib='$privlib'
privlibexp='$privlibexp'
pthread='$pthread'
revision='$revision'
rm='$rm'
rmail='$rmail'
run='$run'
scriptdir='$scriptdir'
scriptdirexp='$scriptdirexp'
sed='$sed'
sendmail='$sendmail'
sh='$sh'
shar='$shar'
sharpbang='$sharpbang'
shsharp='$shsharp'
sleep='$sleep'
smail='$smail'
sort='$sort'
spackage='$spackage'
spitshell='$spitshell'
src='$src'
startperl='$startperl'
startsh='$startsh'
submit='$submit'
sysman='$sysman'
tail='$tail'
tar='$tar'
targetarch='$targetarch'
tbl='$tbl'
tee='$tee'
test='$test'
to='$to'
touch='$touch'
tr='$tr'
trnl='$trnl'
troff='$troff'
uname='$uname'
uniq='$uniq'
usecrosscompile='$usecrosscompile'
usrinc='$usrinc'
uuname='$uuname'
vi='$vi'
wc='$wc'
xgettext='$xgettext'
xlibpth='$xlibpth'
zcat='$zcat'
zip='$zip'
EOT

: add special variables
$test -f $src/patchlevel.h && \
awk '/^#define/ {printf "%s=%s\n",$2,$3}' $src/patchlevel.h >>config.sh
$test -f $src/revision.h && \
sed -ne 's/^#define \([A-Za-z0-9_]*\) ".*: \([0-9]*\).*"/\1=\2/p' \
	< $src/revision.h >>config.sh
echo "CONFIG=true" >>config.sh

: propagate old symbols
if $test -f UU/config.sh; then
	<UU/config.sh $sort | $uniq >UU/oldconfig.sh
	$sed -n 's/^\([a-zA-Z_0-9]*\)=.*/\1/p' \
		config.sh config.sh UU/oldconfig.sh |\
		$sort | $uniq -u >UU/oldsyms
	set X `cat UU/oldsyms`
	shift
	case $# in
	0) ;;
	*)
		cat <<EOM
Hmm...You had some extra variables I don't know about...I'll try to keep 'em...
EOM
		echo ": Variables propagated from previous config.sh file." >>config.sh
		for sym in `cat UU/oldsyms`; do
			echo "    Propagating $hint variable "'$'"$sym..."
			eval 'tmp="$'"${sym}"'"'
			echo "$tmp" | \
				sed -e "s/'/'\"'\"'/g" -e "s/^/$sym='/" -e "s/$/'/" >>config.sh
		done
		;;
	esac
fi

: Finish up by extracting the .SH files
case "$alldone" in
exit)
	echo "Stopping at your request, leaving temporary files around."
	exit 0
	;;
cont)
	;;
'')
	dflt=''
	nostick=true
	$cat <<EOM

If you'd like to make any changes to the config.sh file before I begin
to configure things, do it as a shell escape now (e.g. !vi config.sh).

EOM
	rp="Press return or use a shell escape to edit config.sh:"
	. UU/myread
	nostick=''
	case "$ans" in
	'') ;;
	*) : in case they cannot read
		sh 1>&4 -c "$ans";;
	esac
	;;
esac

: if this fails, just run all the .SH files by hand
. ./config.sh

echo " "
exec 1>&4
pwd=`pwd`
. ./UU/extract
cd "$pwd"

if $contains '^depend:' [Mm]akefile >/dev/null 2>&1; then
	dflt=y
	case "$silent" in
	true) ;;
	*)
		$cat <<EOM

Now you need to generate make dependencies by running "$make depend".
You might prefer to run it in background: "$make depend > makedepend.out &"
It can take a while, so you might not want to run it right now.

EOM
		;;
	esac
	rp="Run $make depend now?"
	. UU/myread
	case "$ans" in
	y*)
		$make depend && echo "Now you must run '$make'."
		;;
	*)
		echo "You must run '$make depend' then '$make'."
		;;
	esac
elif test -f [Mm]akefile; then
	echo " "
	echo "Now you must run a $make."
else
	echo "Configure done."
fi

if $test -f Policy.sh; then
    $cat <<EOM

If you compile $package on a different machine or from a different object
directory, copy the Policy.sh file from this object directory to the
new one before you run Configure -- this will help you with most of
the policy defaults.

EOM
fi
if $test -f UU/config.msg; then
    echo "Hmm.  I also noted the following information while running:"
    echo " "
    $cat UU/config.msg >&4
fi
$rm -f kit*isdone ark*isdone
$rm -rf UU

: End of Configure

